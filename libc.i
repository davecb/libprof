/*
 * libc.i -- generated profiling stats table and
 *	interceptors.
 */

size_t ProfCount = 697;

struct prof_t ProfStats[] = {
	{ "Measurement overhead", 0, 0.0, 0 },
	{ "a64l", 0, 0.0, 0 },
#define A64L 1
	{ "abort", 0, 0.0, 0 },
#define ABORT 2
	{ "abs", 0, 0.0, 0 },
#define ABS 3
	{ "access", 0, 0.0, 0 },
#define ACCESS 4
	{ "acct", 0, 0.0, 0 },
#define ACCT 5
	{ "acl", 0, 0.0, 0 },
#define ACL 6
	{ "addsev", 0, 0.0, 0 },
#define ADDSEV 7
	{ "addseverity", 0, 0.0, 0 },
#define ADDSEVERITY 8
	{ "adjtime", 0, 0.0, 0 },
#define ADJTIME 9
	{ "alarm", 0, 0.0, 0 },
#define ALARM 10
	{ "ascftime", 0, 0.0, 0 },
#define ASCFTIME 11
	{ "asctime", 0, 0.0, 0 },
#define ASCTIME 12
	{ "atexit", 0, 0.0, 0 },
#define ATEXIT 13
	{ "atof", 0, 0.0, 0 },
#define ATOF 14
	{ "atoi", 0, 0.0, 0 },
#define ATOI 15
	{ "atol", 0, 0.0, 0 },
#define ATOL 16
	{ "atoll", 0, 0.0, 0 },
#define ATOLL 17
	{ "attropen", 0, 0.0, 0 },
#define ATTROPEN 18
	{ "basename", 0, 0.0, 0 },
#define BASENAME 19
	{ "bcmp", 0, 0.0, 0 },
#define BCMP 20
	{ "bcopy", 0, 0.0, 0 },
#define BCOPY 21
	{ "bindtextdomain", 0, 0.0, 0 },
#define BINDTEXTDOMAIN 22
	{ "brk", 0, 0.0, 0 },
#define BRK 23
	{ "bsearch", 0, 0.0, 0 },
#define BSEARCH 24
	{ "btowc", 0, 0.0, 0 },
#define BTOWC 25
	{ "bzero", 0, 0.0, 0 },
#define BZERO 26
	{ "calloc", 0, 0.0, 0 },
#define CALLOC 27
	{ "catclose", 0, 0.0, 0 },
#define CATCLOSE 28
	{ "catgets", 0, 0.0, 0 },
#define CATGETS 29
	{ "catopen", 0, 0.0, 0 },
#define CATOPEN 30
	{ "cfgetispeed", 0, 0.0, 0 },
#define CFGETISPEED 31
	{ "cfgetospeed", 0, 0.0, 0 },
#define CFGETOSPEED 32
	{ "cfsetispeed", 0, 0.0, 0 },
#define CFSETISPEED 33
	{ "cfsetospeed", 0, 0.0, 0 },
#define CFSETOSPEED 34
	{ "cftime", 0, 0.0, 0 },
#define CFTIME 35
	{ "chdir", 0, 0.0, 0 },
#define CHDIR 36
	{ "chmod", 0, 0.0, 0 },
#define CHMOD 37
	{ "chown", 0, 0.0, 0 },
#define CHOWN 38
	{ "chroot", 0, 0.0, 0 },
#define CHROOT 39
	{ "clearerr", 0, 0.0, 0 },
#define CLEARERR 40
	{ "clock;", 0, 0.0, 0 },
#define CLOCK 41
	{ "close", 0, 0.0, 0 },
#define CLOSE 42
	{ "closedir", 0, 0.0, 0 },
#define CLOSEDIR 43
	{ "closefrom", 0, 0.0, 0 },
#define CLOSEFROM 44
	{ "closelog", 0, 0.0, 0 },
#define CLOSELOG 45
	{ "confstr", 0, 0.0, 0 },
#define CONFSTR 46
	{ "creat", 0, 0.0, 0 },
#define CREAT 47
	{ "crypt", 0, 0.0, 0 },
#define CRYPT 48
	{ "csetcol", 0, 0.0, 0 },
#define CSETCOL 49
	{ "csetlen", 0, 0.0, 0 },
#define CSETLEN 50
	{ "ctermid", 0, 0.0, 0 },
#define CTERMID 51
	{ "ctime", 0, 0.0, 0 },
#define CTIME_ 52
	{ "cuserid", 0, 0.0, 0 },
#define CUSERID 53
	{ "dcgettext", 0, 0.0, 0 },
#define DCGETTEXT 54
	{ "dcngettext", 0, 0.0, 0 },
#define DCNGETTEXT 55
	{ "dgettext", 0, 0.0, 0 },
#define DGETTEXT 56
	{ "difftime", 0, 0.0, 0 },
#define DIFFTIME 57
	{ "directio", 0, 0.0, 0 },
#define DIRECTIO 58
	{ "dirname", 0, 0.0, 0 },
#define DIRNAME 59
	{ " div", 0, 0.0, 0 },
#define DIV 60
	{ "dngettext", 0, 0.0, 0 },
#define DNGETTEXT 61
	{ "drand48", 0, 0.0, 0 },
#define DRAND48 62
	{ "dup", 0, 0.0, 0 },
#define DUP 63
	{ "dup2", 0, 0.0, 0 },
#define DUP2 64
	{ "econvert", 0, 0.0, 0 },
#define ECONVERT 65
	{ "ecvt", 0, 0.0, 0 },
#define ECVT 66
	{ "encrypt", 0, 0.0, 0 },
#define ENCRYPT 67
	{ "endgrent", 0, 0.0, 0 },
#define ENDGRENT 68
	{ "endnetgrent", 0, 0.0, 0 },
#define ENDNETGRENT 69
	{ "endpwent", 0, 0.0, 0 },
#define ENDPWENT 70
	{ "endspent", 0, 0.0, 0 },
#define ENDSPENT 71
	{ "endutent", 0, 0.0, 0 },
#define ENDUTENT 72
	{ "endutxent", 0, 0.0, 0 },
#define ENDUTXENT 73
	{ "erand48", 0, 0.0, 0 },
#define ERAND48 74
	{ "euccol", 0, 0.0, 0 },
#define EUCCOL 75
	{ "euclen", 0, 0.0, 0 },
#define EUCLEN 76
	{ "eucscol", 0, 0.0, 0 },
#define EUCSCOL 77
	{ "execl", 0, 0.0, 0 },
#define EXECL 78
	{ "execle", 0, 0.0, 0 },
#define EXECLE 79
	{ "execlp", 0, 0.0, 0 },
#define EXECLP 80
	{ "execv", 0, 0.0, 0 },
#define EXECV 81
	{ "execve", 0, 0.0, 0 },
#define EXECVE 82
	{ "execvp", 0, 0.0, 0 },
#define EXECVP 83
	{ "exit", 0, 0.0, 0 },
#define EXIT 84
	{ "facl", 0, 0.0, 0 },
#define FACL 85
	{ "fattach", 0, 0.0, 0 },
#define FATTACH 86
	{ "fchdir", 0, 0.0, 0 },
#define FCHDIR 87
	{ "fchmod", 0, 0.0, 0 },
#define FCHMOD 88
	{ "fchown", 0, 0.0, 0 },
#define FCHOWN 89
	{ "fchownat", 0, 0.0, 0 },
#define FCHOWNAT 90
	{ "fchroot", 0, 0.0, 0 },
#define FCHROOT 91
	{ "fclose", 0, 0.0, 0 },
#define FCLOSE 92
	{ "fcntl", 0, 0.0, 0 },
#define FCNTL 93
	{ "fconvert", 0, 0.0, 0 },
#define FCONVERT 94
	{ "fcvt", 0, 0.0, 0 },
#define FCVT 95
	{ "fdetach", 0, 0.0, 0 },
#define FDETACH 96
	{ "fdopen", 0, 0.0, 0 },
#define FDOPEN 97
	{ "fdopendir", 0, 0.0, 0 },
#define FDOPENDIR 98
	{ "fdwalk", 0, 0.0, 0 },
#define FDWALK 99
	{ "feof", 0, 0.0, 0 },
#define FEOF 100
	{ "ferror", 0, 0.0, 0 },
#define FERROR 101
	{ "fflush", 0, 0.0, 0 },
#define FFLUSH 102
	{ "ffs", 0, 0.0, 0 },
#define FFS 103
	{ "fgetc", 0, 0.0, 0 },
#define FGETC 104
	{ "fgetgrent", 0, 0.0, 0 },
#define FGETGRENT 105
	{ "fgetpos", 0, 0.0, 0 },
#define FGETPOS 106
	{ "fgetpwent", 0, 0.0, 0 },
#define FGETPWENT 107
	{ "fgets", 0, 0.0, 0 },
#define FGETS 108
	{ "fgetspent", 0, 0.0, 0 },
#define FGETSPENT 109
	{ "fgetwc", 0, 0.0, 0 },
#define FGETWC 110
	{ "fgetws", 0, 0.0, 0 },
#define FGETWS 111
	{ "fileno", 0, 0.0, 0 },
#define FILENO 112
	{ "finite", 0, 0.0, 0 },
#define FINITE 113
	{ "flockfile", 0, 0.0, 0 },
#define FLOCKFILE 114
	{ "fmtmsg", 0, 0.0, 0 },
#define FMTMSG 115
	{ "fnmatch", 0, 0.0, 0 },
#define FNMATCH 116
	{ "fopen", 0, 0.0, 0 },
#define FOPEN 117
	{ "fork", 0, 0.0, 0 },
#define FORK 118
	{ "fork1", 0, 0.0, 0 },
#define FORK1 119
	{ "fpathconf", 0, 0.0, 0 },
#define FPATHCONF 120
	{ "fpclass;", 0, 0.0, 0 },
#define FPCLASS 121
	{ " fpgetmask;", 0, 0.0, 0 },
#define FPGETMASK 122
	{ "fpgetround", 0, 0.0, 0 },
#define FPGETROUND 123
	{ "fpgetsticky", 0, 0.0, 0 },
#define FPGETSTICKY 124
	{ "fprintf", 0, 0.0, 0 },
#define FPRINTF 125
	{ "fpsetmask", 0, 0.0, 0 },
#define  FPSETMASK 126
	{ "fpsetround", 0, 0.0, 0 },
#define FPSETROUND 127
	{ "fpsetsticky", 0, 0.0, 0 },
#define FPSETSTICKY 128
	{ "fputc", 0, 0.0, 0 },
#define FPUTC 129
	{ "fputs", 0, 0.0, 0 },
#define FPUTS 130
	{ "fputwc", 0, 0.0, 0 },
#define FPUTWC 131
	{ "fputws", 0, 0.0, 0 },
#define FPUTWS 132
	{ "fread", 0, 0.0, 0 },
#define FREAD 133
	{ "free", 0, 0.0, 0 },
#define FREE 134
	{ "freopen", 0, 0.0, 0 },
#define FREOPEN 135
	{ "frexp", 0, 0.0, 0 },
#define FREXP 136
	{ "fscanf", 0, 0.0, 0 },
#define FSCANF 137
	{ "fseek", 0, 0.0, 0 },
#define FSEEK 138
	{ "fseeko", 0, 0.0, 0 },
#define FSEEKO 139
	{ "fsetpos", 0, 0.0, 0 },
#define FSETPOS 140
	{ "fstat", 0, 0.0, 0 },
#define FSTAT 141
	{ "fstatat", 0, 0.0, 0 },
#define FSTATAT 142
	{ "fstatvfs", 0, 0.0, 0 },
#define FSTATVFS 143
	{ "fsync", 0, 0.0, 0 },
#define FSYNC 144
	{ "ftell", 0, 0.0, 0 },
#define FTELL 145
	{ "ftello", 0, 0.0, 0 },
#define FTELLO 146
	{ "ftime", 0, 0.0, 0 },
#define FTIME 147
	{ "ftok", 0, 0.0, 0 },
#define FTOK 148
	{ "ftruncate", 0, 0.0, 0 },
#define FTRUNCATE 149
	{ "ftrylockfile", 0, 0.0, 0 },
#define FTRYLOCKFILE 150
	{ "ftw", 0, 0.0, 0 },
#define FTW 151
	{ "funlockfile", 0, 0.0, 0 },
#define FUNLOCKFILE 152
	{ "futimesat", 0, 0.0, 0 },
#define FUTIMESAT 153
	{ "fwide", 0, 0.0, 0 },
#define FWIDE 154
	{ "fwprintf", 0, 0.0, 0 },
#define FWPRINTF 155
	{ "fwrite", 0, 0.0, 0 },
#define FWRITE 156
	{ "fwscanf", 0, 0.0, 0 },
#define FWSCANF 157
	{ "gconvert", 0, 0.0, 0 },
#define GCONVERT 158
	{ "gcvt", 0, 0.0, 0 },
#define GCVT 159
	{ "getacct", 0, 0.0, 0 },
#define GETACCT 160
	{ "getc", 0, 0.0, 0 },
#define GETC 161
	{ "getchar", 0, 0.0, 0 },
#define GETCHAR 162
	{ "getcontext", 0, 0.0, 0 },
#define GETCONTEXT_ 163
	{ "getcpuid", 0, 0.0, 0 },
#define GETCPUID 164
	{ "getcwd", 0, 0.0, 0 },
#define GETCWD 165
	{ "getdate", 0, 0.0, 0 },
#define GETDATE 166
	{ "getdents", 0, 0.0, 0 },
#define GETDENTS 167
	{ "getdtablesize", 0, 0.0, 0 },
#define GETDTABLESIZE 168
	{ "getegid", 0, 0.0, 0 },
#define GETEGID 169
	{ "getenv", 0, 0.0, 0 },
#define GETENV 170
	{ "geteuid", 0, 0.0, 0 },
#define GETEUID 171
	{ "getexecname", 0, 0.0, 0 },
#define GETEXECNAME 172
	{ "getextmntent", 0, 0.0, 0 },
#define GETEXTMNTENT 173
	{ "getgid", 0, 0.0, 0 },
#define GETGID 174
	{ "getgrent", 0, 0.0, 0 },
#define GETGRENT 175
	{ "getgrgid", 0, 0.0, 0 },
#define GETGRGID 176
	{ "getgrnam", 0, 0.0, 0 },
#define GETGRNAM 177
	{ "getgroups", 0, 0.0, 0 },
#define GETGROUPS 178
	{ "gethomelgroup", 0, 0.0, 0 },
#define GETHOMELGROUP 179
	{ "gethostid", 0, 0.0, 0 },
#define GETHOSTID 180
	{ "gethostname", 0, 0.0, 0 },
#define GETHOSTNAME 181
	{ "gethrtime", 0, 0.0, 0 },
#define GETHRTIME 182
	{ "gethrvtime", 0, 0.0, 0 },
#define GETHRVTIME 183
	{ "getitimer", 0, 0.0, 0 },
#define GETITIMER 184
	{ "getloadavg", 0, 0.0, 0 },
#define GETLOADAVG 185
	{ "getlogin", 0, 0.0, 0 },
#define GETLOGIN 186
	{ "getmntany", 0, 0.0, 0 },
#define GETMNTANY 187
	{ "getmntent", 0, 0.0, 0 },
#define GETMNTENT 188
	{ "getmsg", 0, 0.0, 0 },
#define GETMSG 189
	{ "getnetgrent", 0, 0.0, 0 },
#define GETNETGRENT 190
	{ "getopt", 0, 0.0, 0 },
#define GETOPT 191
	{ "getpagesize", 0, 0.0, 0 },
#define GETPAGESIZE 192
	{ "getpagesizes", 0, 0.0, 0 },
#define GETPAGESIZES 193
	{ "getpass", 0, 0.0, 0 },
#define GETPASS 194
	{ "getpassphrase", 0, 0.0, 0 },
#define GETPASSPHRASE 195
	{ "getpgid", 0, 0.0, 0 },
#define GETPGID 196
	{ "getpgrp", 0, 0.0, 0 },
#define GETPGRP 197
	{ "getpid", 0, 0.0, 0 },
#define GETPID_ 198
	{ "getpmsg", 0, 0.0, 0 },
#define GETPMSG 199
	{ "getppid", 0, 0.0, 0 },
#define GETPPID 200
	{ "getpriority", 0, 0.0, 0 },
#define GETPRIORITY 201
	{ "getprojid", 0, 0.0, 0 },
#define GETPROJID 202
	{ "getpw", 0, 0.0, 0 },
#define GETPW 203
	{ "getpwent", 0, 0.0, 0 },
#define GETPWENT 204
	{ "getpwnam", 0, 0.0, 0 },
#define GETPWNAM 205
	{ "getpwuid", 0, 0.0, 0 },
#define GETPWUID 206
	{ "getrctl", 0, 0.0, 0 },
#define GETRCTL 207
	{ "getrlimit", 0, 0.0, 0 },
#define GETRLIMIT 208
	{ "getrusage", 0, 0.0, 0 },
#define GETRUSAGE 209
	{ "gets", 0, 0.0, 0 },
#define GETS 210
	{ "getsid", 0, 0.0, 0 },
#define GETSID 211
	{ "getspent", 0, 0.0, 0 },
#define GETSPENT 212
	{ "getspnam", 0, 0.0, 0 },
#define GETSPNAM 213
	{ "getsubopt", 0, 0.0, 0 },
#define GETSUBOPT 214
	{ "gettaskid", 0, 0.0, 0 },
#define GETTASKID 215
	{ "gettext", 0, 0.0, 0 },
#define GETTEXT 216
	{ "gettimeofday", 0, 0.0, 0 },
#define GETTIMEOFDAY 217
	{ "gettxt", 0, 0.0, 0 },
#define GETTXT 218
	{ "getuid", 0, 0.0, 0 },
#define GETUID 219
	{ "getustack", 0, 0.0, 0 },
#define GETUSTACK_ 220
	{ "getutent", 0, 0.0, 0 },
#define GETUTENT 221
	{ "getutid", 0, 0.0, 0 },
#define GETUTID 222
	{ "getutline", 0, 0.0, 0 },
#define GETUTLINE 223
	{ "getutmp", 0, 0.0, 0 },
#define GETUTMP 224
	{ "getutmpx", 0, 0.0, 0 },
#define GETUTMPX 225
	{ "getutxent", 0, 0.0, 0 },
#define GETUTXENT 226
	{ "getutxid", 0, 0.0, 0 },
#define GETUTXID 227
	{ "getutxline", 0, 0.0, 0 },
#define GETUTXLINE 228
	{ "getvfsany", 0, 0.0, 0 },
#define GETVFSANY 229
	{ "getvfsent", 0, 0.0, 0 },
#define GETVFSENT 230
	{ "getvfsfile", 0, 0.0, 0 },
#define GETVFSFILE 231
	{ "getvfsspec", 0, 0.0, 0 },
#define GETVFSSPEC 232
	{ "getw", 0, 0.0, 0 },
#define GETW 233
	{ "getwc", 0, 0.0, 0 },
#define GETWC 234
	{ "getwchar", 0, 0.0, 0 },
#define GETWCHAR 235
	{ "getwd", 0, 0.0, 0 },
#define GETWD 236
	{ "getwidth", 0, 0.0, 0 },
#define GETWIDTH 237
	{ "getws", 0, 0.0, 0 },
#define GETWS 238
	{ "glob", 0, 0.0, 0 },
#define GLOB 239
	{ "globfree", 0, 0.0, 0 },
#define GLOBFREE 240
	{ "gmtime", 0, 0.0, 0 },
#define GMTIME 241
	{ "grantpt", 0, 0.0, 0 },
#define GRANTPT 242
	{ "gsignal", 0, 0.0, 0 },
#define GSIGNAL 243
	{ "hasmntopt", 0, 0.0, 0 },
#define HASMNTOPT 244
	{ "hcreate", 0, 0.0, 0 },
#define HCREATE 245
	{ "hdestroy", 0, 0.0, 0 },
#define HDESTROY 246
	{ "hsearch", 0, 0.0, 0 },
#define HSEARCH 247
	{ "iconv", 0, 0.0, 0 },
#define ICONV 248
	{ "index", 0, 0.0, 0 },
#define INDEX 249
	{ "initgroups", 0, 0.0, 0 },
#define INITGROUPS 250
	{ "initstate", 0, 0.0, 0 },
#define INITSTATE 251
	{ "innetgr", 0, 0.0, 0 },
#define INNETGR 252
	{ "insque", 0, 0.0, 0 },
#define INSQUE 253
	{ "ioctl", 0, 0.0, 0 },
#define IOCTL 254
	{ "isaexec", 0, 0.0, 0 },
#define ISAEXEC 255
	{ "isalnum", 0, 0.0, 0 },
#define ISALNUM 256
	{ "isalpha", 0, 0.0, 0 },
#define ISALPHA 257
	{ "isascii", 0, 0.0, 0 },
#define ISASCII_ 258
	{ "isastream", 0, 0.0, 0 },
#define ISASTREAM 259
	{ "isatty", 0, 0.0, 0 },
#define ISATTY 260
	{ "iscntrl", 0, 0.0, 0 },
#define ISCNTRL 261
	{ "isdigit", 0, 0.0, 0 },
#define ISDIGIT 262
	{ "isgraph", 0, 0.0, 0 },
#define ISGRAPH 263
	{ "islower", 0, 0.0, 0 },
#define ISLOWER 264
	{ "isnan", 0, 0.0, 0 },
#define ISNAN 265
	{ "isnand", 0, 0.0, 0 },
#define ISNAND 266
	{ "isnanf", 0, 0.0, 0 },
#define ISNANF 267
	{ "isprint", 0, 0.0, 0 },
#define ISPRINT_ 268
	{ "ispunct", 0, 0.0, 0 },
#define ISPUNCT 269
	{ "issetugid", 0, 0.0, 0 },
#define ISSETUGID 270
	{ "isspace", 0, 0.0, 0 },
#define ISSPACE 271
	{ "isupper", 0, 0.0, 0 },
#define ISUPPER 272
	{ "iswalpha", 0, 0.0, 0 },
#define ISWALPHA 273
	{ "iswctype", 0, 0.0, 0 },
#define ISWCTYPE 274
	{ "isxdigit", 0, 0.0, 0 },
#define ISXDIGIT 275
	{ "jrand48", 0, 0.0, 0 },
#define JRAND48 276
	{ "kill", 0, 0.0, 0 },
#define KILL 277
	{ "killpg", 0, 0.0, 0 },
#define KILLPG 278
	{ "l64a", 0, 0.0, 0 },
#define L64A 279
	{ "labs", 0, 0.0, 0 },
#define LABS 280
	{ "lchown", 0, 0.0, 0 },
#define LCHOWN 281
	{ "lckpwdf", 0, 0.0, 0 },
#define LCKPWDF 282
	{ "lcong48", 0, 0.0, 0 },
#define LCONG48 283
	{ "ldexp", 0, 0.0, 0 },
#define LDEXP 284
	{ "ldiv", 0, 0.0, 0 },
#define  LDIV 285
	{ "lfind", 0, 0.0, 0 },
#define  LFIND 286
	{ "lfmt", 0, 0.0, 0 },
#define LFMT 287
	{ "link", 0, 0.0, 0 },
#define LINK 288
	{ "llabs", 0, 0.0, 0 },
#define LLABS 289
	{ "lldiv", 0, 0.0, 0 },
#define LLDIV 290
	{ "llseek", 0, 0.0, 0 },
#define LLSEEK 291
	{ "lltostr", 0, 0.0, 0 },
#define LLTOSTR 292
	{ "localeconv", 0, 0.0, 0 },
#define LOCALECONV 293
	{ "localtime", 0, 0.0, 0 },
#define LOCALTIME 294
	{ "lockf", 0, 0.0, 0 },
#define LOCKF 295
	{ "longjmp", 0, 0.0, 0 },
#define LONGJMP 296
	{ "lrand48", 0, 0.0, 0 },
#define LRAND48 297
	{ "lsearch", 0, 0.0, 0 },
#define LSEARCH 298
	{ "lseek", 0, 0.0, 0 },
#define LSEEK 299
	{ "lstat", 0, 0.0, 0 },
#define LSTAT 300
	{ "madvise", 0, 0.0, 0 },
#define MADVISE 301
	{ "makecontext", 0, 0.0, 0 },
#define MAKECONTEXT 302
	{ "malloc", 0, 0.0, 0 },
#define MALLOC 303
	{ "mblen", 0, 0.0, 0 },
#define MBLEN 304
	{ "mbrlen", 0, 0.0, 0 },
#define MBRLEN 305
	{ "mbrtowc", 0, 0.0, 0 },
#define MBRTOWC 306
	{ "mbsinit", 0, 0.0, 0 },
#define MBSINIT 307
	{ "mbsrtowcs", 0, 0.0, 0 },
#define MBSRTOWCS 308
	{ "mbstowcs", 0, 0.0, 0 },
#define MBSTOWCS 309
	{ "mbtowc", 0, 0.0, 0 },
#define MBTOWC 310
	{ "memalign", 0, 0.0, 0 },
#define MEMALIGN 311
	{ "memccpy", 0, 0.0, 0 },
#define MEMCCPY 312
	{ "memchr", 0, 0.0, 0 },
#define MEMCHR 313
	{ "memcmp", 0, 0.0, 0 },
#define MEMCMP 314
	{ "memcntl", 0, 0.0, 0 },
#define MEMCNTL 315
	{ "memcpy", 0, 0.0, 0 },
#define MEMCPY 316
	{ "meminfo", 0, 0.0, 0 },
#define MEMINFO 317
	{ "memmove", 0, 0.0, 0 },
#define MEMMOVE 318
	{ "memset", 0, 0.0, 0 },
#define MEMSET 319
	{ "mincore", 0, 0.0, 0 },
#define MINCORE 320
	{ "mkdir", 0, 0.0, 0 },
#define MKDIR 321
	{ "mkfifo", 0, 0.0, 0 },
#define MKFIFO 322
	{ "mknod", 0, 0.0, 0 },
#define MKNOD 323
	{ "mkstemp", 0, 0.0, 0 },
#define MKSTEMP 324
	{ "mktemp", 0, 0.0, 0 },
#define MKTEMP 325
	{ "mktime", 0, 0.0, 0 },
#define MKTIME 326
	{ "mlock", 0, 0.0, 0 },
#define MLOCK 327
	{ "mlockall", 0, 0.0, 0 },
#define MLOCKALL 328
	{ "mmap", 0, 0.0, 0 },
#define MMAP 329
	{ "modf", 0, 0.0, 0 },
#define MODF 330
	{ "modff", 0, 0.0, 0 },
#define MODFF 331
	{ "monitor", 0, 0.0, 0 },
#define MONITOR 332
	{ "mount", 0, 0.0, 0 },
#define MOUNT 333
	{ "mprotect", 0, 0.0, 0 },
#define MPROTECT 334
	{ "mrand48", 0, 0.0, 0 },
#define MRAND48 335
	{ "msgctl", 0, 0.0, 0 },
#define MSGCTL 336
	{ "msgget", 0, 0.0, 0 },
#define MSGGET 337
	{ "msgids", 0, 0.0, 0 },
#define MSGIDS 338
	{ "msgrcv", 0, 0.0, 0 },
#define MSGRCV 339
	{ "msgsnap", 0, 0.0, 0 },
#define MSGSNAP 340
	{ "msgsnd", 0, 0.0, 0 },
#define MSGSND 341
	{ "msync", 0, 0.0, 0 },
#define MSYNC 342
	{ "munlock", 0, 0.0, 0 },
#define MUNLOCK 343
	{ "munlockall", 0, 0.0, 0 },
#define MUNLOCKALL 344
	{ "munmap", 0, 0.0, 0 },
#define MUNMAP 345
	{ "nftw", 0, 0.0, 0 },
#define NFTW 346
	{ "ngettext", 0, 0.0, 0 },
#define NGETTEXT 347
	{ "nice", 0, 0.0, 0 },
#define NICE 348
	{ "nrand48", 0, 0.0, 0 },
#define NRAND48 349
	{ "open", 0, 0.0, 0 },
#define OPEN 350
	{ "openat", 0, 0.0, 0 },
#define OPENAT 351
	{ "opendir", 0, 0.0, 0 },
#define OPENDIR 352
	{ "openlog", 0, 0.0, 0 },
#define OPENLOG 353
	{ "pathconf", 0, 0.0, 0 },
#define PATHCONF 354
	{ "pause", 0, 0.0, 0 },
#define PAUSE 355
	{ "pclose", 0, 0.0, 0 },
#define PCLOSE 356
	{ "pcsample", 0, 0.0, 0 },
#define PCSAMPLE 357
	{ "perror", 0, 0.0, 0 },
#define PERROR 358
	{ "pfmt", 0, 0.0, 0 },
#define PFMT 359
	{ "pipe", 0, 0.0, 0 },
#define PIPE 360
	{ "plock", 0, 0.0, 0 },
#define PLOCK 361
	{ "poll", 0, 0.0, 0 },
#define POLL 362
	{ "popen", 0, 0.0, 0 },
#define POPEN 363
	{ "pread", 0, 0.0, 0 },
#define PREAD 364
	{ "printf", 0, 0.0, 0 },
#define PRINTF 365
	{ "printstack", 0, 0.0, 0 },
#define PRINTSTACK 366
	{ "priocntl", 0, 0.0, 0 },
#define PRIOCNTL 367
	{ "priocntlset", 0, 0.0, 0 },
#define PRIOCNTLSET 368
	{ "profil", 0, 0.0, 0 },
#define PROFIL 369
	{ "psiginfo", 0, 0.0, 0 },
#define PSIGINFO 370
	{ "psignal", 0, 0.0, 0 },
#define PSIGNAL 371
	{ "ptrace", 0, 0.0, 0 },
#define PTRACE 372
	{ "ptsname", 0, 0.0, 0 },
#define PTSNAME 373
	{ "putacct", 0, 0.0, 0 },
#define PUTACCT 374
	{ "putc", 0, 0.0, 0 },
#define PUTC 375
	{ "putchar", 0, 0.0, 0 },
#define PUTCHAR 376
	{ "putenv", 0, 0.0, 0 },
#define PUTENV 377
	{ "putmsg", 0, 0.0, 0 },
#define PUTMSG 378
	{ "putpmsg", 0, 0.0, 0 },
#define PUTPMSG 379
	{ "putpwent", 0, 0.0, 0 },
#define PUTPWENT 380
	{ "puts", 0, 0.0, 0 },
#define PUTS 381
	{ "putspent", 0, 0.0, 0 },
#define PUTSPENT 382
	{ "pututline", 0, 0.0, 0 },
#define PUTUTLINE 383
	{ "pututxline", 0, 0.0, 0 },
#define PUTUTXLINE 384
	{ "putw", 0, 0.0, 0 },
#define PUTW 385
	{ "putwc", 0, 0.0, 0 },
#define PUTWC 386
	{ "putwchar", 0, 0.0, 0 },
#define PUTWCHAR 387
	{ "putws", 0, 0.0, 0 },
#define PUTWS 388
	{ "pwrite", 0, 0.0, 0 },
#define PWRITE 389
	{ "qeconvert", 0, 0.0, 0 },
#define QECONVERT 390
	{ "qfconvert", 0, 0.0, 0 },
#define QFCONVERT 391
	{ "qgconvert", 0, 0.0, 0 },
#define QGCONVERT 392
	{ "qsort", 0, 0.0, 0 },
#define QSORT 393
	{ "raise", 0, 0.0, 0 },
#define RAISE 394
	{ "rand", 0, 0.0, 0 },
#define RAND 395
	{ "random", 0, 0.0, 0 },
#define RANDOM 396
	{ "read", 0, 0.0, 0 },
#define READ 397
	{ "readdir", 0, 0.0, 0 },
#define READDIR 398
	{ "readlink", 0, 0.0, 0 },
#define READLINK 399
	{ "readv", 0, 0.0, 0 },
#define READV 400
	{ "realloc", 0, 0.0, 0 },
#define REALLOC 401
	{ "realpath", 0, 0.0, 0 },
#define REALPATH 402
	{ "reboot", 0, 0.0, 0 },
#define REBOOT 403
	{ "regcmp", 0, 0.0, 0 },
#define REGCMP 404
	{ "regcomp", 0, 0.0, 0 },
#define REGCOMP 405
	{ "regerror", 0, 0.0, 0 },
#define REGERROR 406
	{ "regex", 0, 0.0, 0 },
#define REGEX 407
	{ "regexec", 0, 0.0, 0 },
#define REGEXEC 408
	{ "regfree", 0, 0.0, 0 },
#define REGFREE 409
	{ "remove", 0, 0.0, 0 },
#define REMOVE 410
	{ "remque", 0, 0.0, 0 },
#define REMQUE 411
	{ "rename", 0, 0.0, 0 },
#define RENAME 412
	{ "renameat", 0, 0.0, 0 },
#define RENAMEAT 413
	{ "resetmnttab", 0, 0.0, 0 },
#define RESETMNTTAB 414
	{ "resolvepath", 0, 0.0, 0 },
#define RESOLVEPATH 415
	{ "rewind", 0, 0.0, 0 },
#define REWIND 416
	{ "rewinddir", 0, 0.0, 0 },
#define REWINDDIR 417
	{ "rindex", 0, 0.0, 0 },
#define RINDEX 418
	{ "rmdir", 0, 0.0, 0 },
#define RMDIR 419
	{ "sbrk", 0, 0.0, 0 },
#define SBRK 420
	{ "scanf", 0, 0.0, 0 },
#define SCANF 421
	{ "seconvert", 0, 0.0, 0 },
#define SECONVERT 422
	{ "seed48", 0, 0.0, 0 },
#define SEED48 423
	{ "seekdir", 0, 0.0, 0 },
#define SEEKDIR 424
	{ "select", 0, 0.0, 0 },
#define SELECT 425
	{ "semctl", 0, 0.0, 0 },
#define SEMCTL 426
	{ "semget", 0, 0.0, 0 },
#define SEMGET 427
	{ "semids", 0, 0.0, 0 },
#define SEMIDS 428
	{ "semop", 0, 0.0, 0 },
#define SEMOP 429
	{ "semtimedop", 0, 0.0, 0 },
#define SEMTIMEDOP 430
	{ "setbuf", 0, 0.0, 0 },
#define SETBUF 431
	{ "setbuffer", 0, 0.0, 0 },
#define SETBUFFER 432
	{ "setcat", 0, 0.0, 0 },
#define SETCAT 433
	{ "setcontext", 0, 0.0, 0 },
#define SETCONTEXT_ 434
	{ "setegid", 0, 0.0, 0 },
#define SETEGID 435
	{ "seteuid", 0, 0.0, 0 },
#define SETEUID 436
	{ "setgid", 0, 0.0, 0 },
#define SETGID 437
	{ "setgrent", 0, 0.0, 0 },
#define SETGRENT 438
	{ "setgroups", 0, 0.0, 0 },
#define SETGROUPS 439
	{ "sethostname", 0, 0.0, 0 },
#define SETHOSTNAME 440
	{ "setitimer", 0, 0.0, 0 },
#define SETITIMER 441
	{ "setjmp", 0, 0.0, 0 },
#define SETJMP 442
	{ "setkey", 0, 0.0, 0 },
#define SETKEY 443
	{ "setlabel", 0, 0.0, 0 },
#define SETLABEL 444
	{ "setlinebuf", 0, 0.0, 0 },
#define SETLINEBUF 445
	{ "setlocale", 0, 0.0, 0 },
#define SETLOCALE 446
	{ "setlogmask", 0, 0.0, 0 },
#define SETLOGMASK 447
	{ "setnetgrent", 0, 0.0, 0 },
#define SETNETGRENT 448
	{ "setpgid", 0, 0.0, 0 },
#define SETPGID 449
	{ "setpgrp", 0, 0.0, 0 },
#define SETPGRP 450
	{ "setpriority", 0, 0.0, 0 },
#define SETPRIORITY 451
	{ "setpwent", 0, 0.0, 0 },
#define SETPWENT 452
	{ "setrctl", 0, 0.0, 0 },
#define SETRCTL 453
	{ "setregid", 0, 0.0, 0 },
#define SETREGID 454
	{ "setreuid", 0, 0.0, 0 },
#define SETREUID 455
	{ "setrlimit", 0, 0.0, 0 },
#define SETRLIMIT 456
	{ "setsid", 0, 0.0, 0 },
#define SETSID 457
	{ "setspent", 0, 0.0, 0 },
#define SETSPENT 458
	{ "setstate", 0, 0.0, 0 },
#define SETSTATE 459
	{ "settaskid", 0, 0.0, 0 },
#define SETTASKID 460
	{ "settimeofday", 0, 0.0, 0 },
#define SETTIMEOFDAY 461
	{ "setuid", 0, 0.0, 0 },
#define SETUID 462
	{ "setustack", 0, 0.0, 0 },
#define SETUSTACK_ 463
	{ "setutent", 0, 0.0, 0 },
#define SETUTENT 464
	{ "setutxent", 0, 0.0, 0 },
#define SETUTXENT 465
	{ "setvbuf", 0, 0.0, 0 },
#define SETVBUF 466
	{ "sfconvert", 0, 0.0, 0 },
#define SFCONVERT 467
	{ "sgconvert", 0, 0.0, 0 },
#define SGCONVERT 468
	{ "shmat", 0, 0.0, 0 },
#define SHMAT 469
	{ "shmctl", 0, 0.0, 0 },
#define SHMCTL 470
	{ "shmdt", 0, 0.0, 0 },
#define SHMDT 471
	{ "shmget", 0, 0.0, 0 },
#define SHMGET 472
	{ "shmids", 0, 0.0, 0 },
#define SHMIDS 473
	{ "sig2str", 0, 0.0, 0 },
#define SIG2STR 474
	{ "sigaction", 0, 0.0, 0 },
#define SIGACTION 475
	{ "sigaddset", 0, 0.0, 0 },
#define SIGADDSET 476
	{ "sigaltstack", 0, 0.0, 0 },
#define SIGALTSTACK 477
	{ "sigdelset", 0, 0.0, 0 },
#define SIGDELSET 478
	{ "sigemptyset", 0, 0.0, 0 },
#define SIGEMPTYSET 479
	{ "sigfillset", 0, 0.0, 0 },
#define SIGFILLSET 480
	{ "sigfpe", 0, 0.0, 0 },
#define SIGFPE_ 481
	{ "sighold", 0, 0.0, 0 },
#define SIGHOLD_ 482
	{ "sigignore", 0, 0.0, 0 },
#define SIGIGNORE_ 483
	{ "sigismember", 0, 0.0, 0 },
#define SIGISMEMBER 484
	{ "siglongjmp", 0, 0.0, 0 },
#define SIGLONGJMP 485
	{ "sigpause", 0, 0.0, 0 },
#define SIGPAUSE_ 486
	{ "sigpending", 0, 0.0, 0 },
#define SIGPENDING 487
	{ "sigprocmask", 0, 0.0, 0 },
#define SIGPROCMASK 488
	{ "sigrelse", 0, 0.0, 0 },
#define SIGRELSE_ 489
	{ "sigsend", 0, 0.0, 0 },
#define SIGSEND 490
	{ "sigsendset", 0, 0.0, 0 },
#define SIGSENDSET 491
	{ "sigset", 0, 0.0, 0 },
#define SIGSET 492
	{ "sigsetjmp", 0, 0.0, 0 },
#define SIGSETJMP 493
	{ "sigstack", 0, 0.0, 0 },
#define SIGSTACK 494
	{ "sigsuspend", 0, 0.0, 0 },
#define SIGSUSPEND 495
	{ "sigwait", 0, 0.0, 0 },
#define SIGWAIT 496
	{ "sleep", 0, 0.0, 0 },
#define SLEEP 497
	{ "snprintf", 0, 0.0, 0 },
#define SNPRINTF 498
	{ "sprintf", 0, 0.0, 0 },
#define SPRINTF 499
	{ "srand", 0, 0.0, 0 },
#define SRAND 500
	{ "srand48", 0, 0.0, 0 },
#define SRAND48 501
	{ "srandom", 0, 0.0, 0 },
#define SRANDOM 502
	{ "sscanf", 0, 0.0, 0 },
#define SSCANF 503
	{ "stat", 0, 0.0, 0 },
#define STAT 504
	{ "statvfs", 0, 0.0, 0 },
#define STATVFS 505
	{ "stime", 0, 0.0, 0 },
#define STIME 506
	{ "str2sig", 0, 0.0, 0 },
#define STR2SIG 507
	{ "strcasecmp", 0, 0.0, 0 },
#define STRCASECMP 508
	{ "strcat", 0, 0.0, 0 },
#define STRCAT 509
	{ "strchr", 0, 0.0, 0 },
#define STRCHR 510
	{ "strcmp", 0, 0.0, 0 },
#define STRCMP 511
	{ "strcoll", 0, 0.0, 0 },
#define STRCOLL 512
	{ "strcpy", 0, 0.0, 0 },
#define STRCPY 513
	{ "strcspn", 0, 0.0, 0 },
#define STRCSPN 514
	{ "strdup", 0, 0.0, 0 },
#define STRDUP 515
	{ "strerror", 0, 0.0, 0 },
#define STRERROR 516
	{ "strfmon", 0, 0.0, 0 },
#define STRFMON 517
	{ "strftime", 0, 0.0, 0 },
#define STRFTIME 518
	{ "strlcat", 0, 0.0, 0 },
#define STRLCAT 519
	{ "strlcpy", 0, 0.0, 0 },
#define STRLCPY 520
	{ "strlen", 0, 0.0, 0 },
#define STRLEN 521
	{ "strncasecmp", 0, 0.0, 0 },
#define STRNCASECMP 522
	{ "strncat", 0, 0.0, 0 },
#define STRNCAT 523
	{ "strncmp", 0, 0.0, 0 },
#define STRNCMP 524
	{ "strncpy", 0, 0.0, 0 },
#define STRNCPY 525
	{ "strpbrk", 0, 0.0, 0 },
#define STRPBRK 526
	{ "strptime", 0, 0.0, 0 },
#define STRPTIME 527
	{ "strrchr", 0, 0.0, 0 },
#define STRRCHR 528
	{ "strsignal", 0, 0.0, 0 },
#define STRSIGNAL 529
	{ "strspn", 0, 0.0, 0 },
#define STRSPN 530
	{ "strstr", 0, 0.0, 0 },
#define STRSTR 531
	{ "strtod", 0, 0.0, 0 },
#define STRTOD 532
	{ "strtok", 0, 0.0, 0 },
#define STRTOK 533
	{ "strtol", 0, 0.0, 0 },
#define STRTOL 534
	{ "strtoll", 0, 0.0, 0 },
#define STRTOLL 535
	{ "strtoul", 0, 0.0, 0 },
#define STRTOUL 536
	{ "strtoull", 0, 0.0, 0 },
#define STRTOULL 537
	{ "strtows", 0, 0.0, 0 },
#define STRTOWS 538
	{ "strxfrm", 0, 0.0, 0 },
#define STRXFRM 539
	{ "swab", 0, 0.0, 0 },
#define SWAB 540
	{ "swapcontext", 0, 0.0, 0 },
#define SWAPCONTEXT 541
	{ "swapctl", 0, 0.0, 0 },
#define SWAPCTL 542
	{ "swprintf", 0, 0.0, 0 },
#define SWPRINTF 543
	{ "swscanf", 0, 0.0, 0 },
#define SWSCANF 544
	{ "symlink", 0, 0.0, 0 },
#define SYMLINK 545
	{ "sync", 0, 0.0, 0 },
#define SYNC 546
	{ "sysconf", 0, 0.0, 0 },
#define SYSCONF 547
	{ "sysfs", 0, 0.0, 0 },
#define SYSFS 548
	{ "sysinfo", 0, 0.0, 0 },
#define SYSINFO 549
	{ "syslog", 0, 0.0, 0 },
#define SYSLOG 550
	{ "system", 0, 0.0, 0 },
#define SYSTEM 551
	{ "tcdrain", 0, 0.0, 0 },
#define TCDRAIN 552
	{ "tcflow", 0, 0.0, 0 },
#define TCFLOW 553
	{ "tcflush", 0, 0.0, 0 },
#define TCFLUSH 554
	{ "tcgetattr", 0, 0.0, 0 },
#define TCGETATTR 555
	{ "tcgetpgrp", 0, 0.0, 0 },
#define TCGETPGRP 556
	{ "tcgetsid", 0, 0.0, 0 },
#define TCGETSID 557
	{ "tcsendbreak", 0, 0.0, 0 },
#define TCSENDBREAK 558
	{ "tcsetattr", 0, 0.0, 0 },
#define TCSETATTR 559
	{ "tcsetpgrp", 0, 0.0, 0 },
#define TCSETPGRP 560
	{ "tdelete", 0, 0.0, 0 },
#define TDELETE 561
	{ "tell", 0, 0.0, 0 },
#define TELL 562
	{ "telldir", 0, 0.0, 0 },
#define TELLDIR 563
	{ "tempnam", 0, 0.0, 0 },
#define TEMPNAM 564
	{ "textdomain", 0, 0.0, 0 },
#define TEXTDOMAIN 565
	{ "tfind", 0, 0.0, 0 },
#define  TFIND 566
	{ "time", 0, 0.0, 0 },
#define TIME 567
	{ "times", 0, 0.0, 0 },
#define TIMES 568
	{ "tmpfile", 0, 0.0, 0 },
#define TMPFILE 569
	{ "tmpnam", 0, 0.0, 0 },
#define TMPNAM 570
	{ "toascii", 0, 0.0, 0 },
#define TOASCII 571
	{ "tolower", 0, 0.0, 0 },
#define TOLOWER 572
	{ "toupper", 0, 0.0, 0 },
#define TOUPPER 573
	{ "towctrans", 0, 0.0, 0 },
#define TOWCTRANS 574
	{ "towlower", 0, 0.0, 0 },
#define TOWLOWER 575
	{ "towupper", 0, 0.0, 0 },
#define TOWUPPER 576
	{ "truncate", 0, 0.0, 0 },
#define TRUNCATE 577
	{ "tsearch", 0, 0.0, 0 },
#define TSEARCH 578
	{ "ttyname", 0, 0.0, 0 },
#define TTYNAME 579
	{ "ttyslot", 0, 0.0, 0 },
#define TTYSLOT 580
	{ "twalk", 0, 0.0, 0 },
#define TWALK 581
	{ "tzset", 0, 0.0, 0 },
#define TZSET 582
	{ "uadmin", 0, 0.0, 0 },
#define UADMIN 583
	{ "ualarm", 0, 0.0, 0 },
#define UALARM 584
	{ "ulckpwdf", 0, 0.0, 0 },
#define ULCKPWDF 585
	{ "ulimit", 0, 0.0, 0 },
#define ULIMIT 586
	{ "ulltostr", 0, 0.0, 0 },
#define ULLTOSTR 587
	{ "umask", 0, 0.0, 0 },
#define UMASK 588
	{ "umount", 0, 0.0, 0 },
#define UMOUNT 589
	{ "umount2", 0, 0.0, 0 },
#define UMOUNT2 590
	{ "uname", 0, 0.0, 0 },
#define UNAME 591
	{ "ungetc", 0, 0.0, 0 },
#define UNGETC 592
	{ "ungetwc", 0, 0.0, 0 },
#define UNGETWC 593
	{ "unlink", 0, 0.0, 0 },
#define UNLINK 594
	{ "unlinkat", 0, 0.0, 0 },
#define UNLINKAT 595
	{ "unlockpt", 0, 0.0, 0 },
#define UNLOCKPT 596
	{ "unordered", 0, 0.0, 0 },
#define UNORDERED 597
	{ "updwtmp", 0, 0.0, 0 },
#define UPDWTMP 598
	{ "updwtmpx", 0, 0.0, 0 },
#define UPDWTMPX 599
	{ "usleep", 0, 0.0, 0 },
#define USLEEP 600
	{ "ustat", 0, 0.0, 0 },
#define USTAT 601
	{ "utime", 0, 0.0, 0 },
#define UTIME 602
	{ "utimes", 0, 0.0, 0 },
#define UTIMES 603
	{ "utmpname", 0, 0.0, 0 },
#define UTMPNAME 604
	{ "utmpxname", 0, 0.0, 0 },
#define UTMPXNAME 605
	{ "valloc", 0, 0.0, 0 },
#define VALLOC 606
	{ "vfork", 0, 0.0, 0 },
#define VFORK 607
	{ "vfprintf", 0, 0.0, 0 },
#define VFPRINTF 608
	{ "vfscanf", 0, 0.0, 0 },
#define VFSCANF 609
	{ "vfwprintf", 0, 0.0, 0 },
#define VFWPRINTF 610
	{ "vfwscanf", 0, 0.0, 0 },
#define VFWSCANF 611
	{ "vhangup", 0, 0.0, 0 },
#define VHANGUP 612
	{ "vlfmt", 0, 0.0, 0 },
#define VLFMT 613
	{ "vpfmt", 0, 0.0, 0 },
#define VPFMT 614
	{ "vprintf", 0, 0.0, 0 },
#define VPRINTF 615
	{ "vscanf", 0, 0.0, 0 },
#define VSCANF 616
	{ "vsnprintf", 0, 0.0, 0 },
#define VSNPRINTF 617
	{ "vsprintf", 0, 0.0, 0 },
#define VSPRINTF 618
	{ "vsscanf", 0, 0.0, 0 },
#define VSSCANF 619
	{ "vswprintf", 0, 0.0, 0 },
#define VSWPRINTF 620
	{ "vswscanf", 0, 0.0, 0 },
#define VSWSCANF 621
	{ "vsyslog", 0, 0.0, 0 },
#define VSYSLOG 622
	{ "vwprintf", 0, 0.0, 0 },
#define VWPRINTF 623
	{ "wait", 0, 0.0, 0 },
#define WAIT 624
	{ "wait3", 0, 0.0, 0 },
#define WAIT3 625
	{ "wait4", 0, 0.0, 0 },
#define WAIT4 626
	{ "waitid", 0, 0.0, 0 },
#define WAITID 627
	{ "waitpid", 0, 0.0, 0 },
#define WAITPID 628
	{ "walkcontext", 0, 0.0, 0 },
#define WALKCONTEXT 629
	{ "watoll", 0, 0.0, 0 },
#define WATOLL 630
	{ "wcrtomb", 0, 0.0, 0 },
#define WCRTOMB 631
	{ "wcscat", 0, 0.0, 0 },
#define WCSCAT 632
	{ "wcschr", 0, 0.0, 0 },
#define WCSCHR 633
	{ "wcscmp", 0, 0.0, 0 },
#define WCSCMP 634
	{ "wcscoll", 0, 0.0, 0 },
#define WCSCOLL 635
	{ "wcscpy", 0, 0.0, 0 },
#define WCSCPY 636
	{ "wcscspn", 0, 0.0, 0 },
#define WCSCSPN 637
	{ "wcsftime", 0, 0.0, 0 },
#define WCSFTIME 638
	{ "wcslen", 0, 0.0, 0 },
#define WCSLEN 639
	{ "wcsncat", 0, 0.0, 0 },
#define WCSNCAT 640
	{ "wcsncmp", 0, 0.0, 0 },
#define WCSNCMP 641
	{ "wcsncpy", 0, 0.0, 0 },
#define WCSNCPY 642
	{ "wcspbrk", 0, 0.0, 0 },
#define WCSPBRK 643
	{ "wcsrchr", 0, 0.0, 0 },
#define WCSRCHR 644
	{ "wcsrtombs", 0, 0.0, 0 },
#define WCSRTOMBS 645
	{ "wcsspn", 0, 0.0, 0 },
#define WCSSPN 646
	{ "wcsstr", 0, 0.0, 0 },
#define WCSSTR 647
	{ "wcstod", 0, 0.0, 0 },
#define WCSTOD 648
	{ "wcstok", 0, 0.0, 0 },
#define WCSTOK 649
	{ "wcstol", 0, 0.0, 0 },
#define WCSTOL 650
	{ "wcstombs", 0, 0.0, 0 },
#define WCSTOMBS 651
	{ "wcstoul", 0, 0.0, 0 },
#define WCSTOUL 652
	{ "wcswcs", 0, 0.0, 0 },
#define WCSWCS 653
	{ "wcswidth", 0, 0.0, 0 },
#define WCSWIDTH 654
	{ "wcsxfrm", 0, 0.0, 0 },
#define WCSXFRM 655
	{ "wctob", 0, 0.0, 0 },
#define WCTOB 656
	{ "wctomb", 0, 0.0, 0 },
#define WCTOMB 657
	{ "wctrans", 0, 0.0, 0 },
#define WCTRANS 658
	{ "wctype", 0, 0.0, 0 },
#define WCTYPE 659
	{ "wcwidth", 0, 0.0, 0 },
#define WCWIDTH 660
	{ "wmemchr", 0, 0.0, 0 },
#define WMEMCHR 661
	{ "wmemcmp", 0, 0.0, 0 },
#define WMEMCMP 662
	{ "wmemcpy", 0, 0.0, 0 },
#define WMEMCPY 663
	{ "wmemmove", 0, 0.0, 0 },
#define WMEMMOVE 664
	{ "wmemset", 0, 0.0, 0 },
#define WMEMSET 665
	{ "wordexp", 0, 0.0, 0 },
#define WORDEXP 666
	{ "wordfree", 0, 0.0, 0 },
#define WORDFREE 667
	{ "wprintf", 0, 0.0, 0 },
#define WPRINTF 668
	{ "wracct", 0, 0.0, 0 },
#define WRACCT 669
	{ "write", 0, 0.0, 0 },
#define WRITE 670
	{ "writev", 0, 0.0, 0 },
#define WRITEV 671
	{ "wscanf", 0, 0.0, 0 },
#define WSCANF 672
	{ "wscasecmp", 0, 0.0, 0 },
#define WSCASECMP 673
	{ "wscat", 0, 0.0, 0 },
#define WSCAT 674
	{ "wschr", 0, 0.0, 0 },
#define WSCHR 675
	{ "wscmp", 0, 0.0, 0 },
#define WSCMP 676
	{ "wscol", 0, 0.0, 0 },
#define WSCOL 677
	{ "wscoll", 0, 0.0, 0 },
#define WSCOLL 678
	{ "wscpy", 0, 0.0, 0 },
#define WSCPY 679
	{ "wscspn", 0, 0.0, 0 },
#define WSCSPN 680
	{ "wsdup", 0, 0.0, 0 },
#define WSDUP 681
	{ "wslen", 0, 0.0, 0 },
#define WSLEN 682
	{ "wsncasecmp", 0, 0.0, 0 },
#define WSNCASECMP 683
	{ "wsncat", 0, 0.0, 0 },
#define WSNCAT 684
	{ "wsncmp", 0, 0.0, 0 },
#define WSNCMP 685
	{ "wsncpy", 0, 0.0, 0 },
#define WSNCPY 686
	{ "wspbrk", 0, 0.0, 0 },
#define WSPBRK 687
	{ "wsprintf", 0, 0.0, 0 },
#define WSPRINTF 688
	{ "wsrchr", 0, 0.0, 0 },
#define WSRCHR 689
	{ "wsscanf", 0, 0.0, 0 },
#define WSSCANF 690
	{ "wsspn", 0, 0.0, 0 },
#define WSSPN 691
	{ "wstod", 0, 0.0, 0 },
#define WSTOD 692
	{ "wstok", 0, 0.0, 0 },
#define WSTOK 693
	{ "wstol", 0, 0.0, 0 },
#define WSTOL 694
	{ "wstostr", 0, 0.0, 0 },
#define WSTOSTR 695
	{ "wsxfrm", 0, 0.0, 0 },
#define WSXFRM 696
	{ "yield", 0, 0.0, 0 },
#define YIELD 697
	{ NULL, 0, 0.0, 0 }
};


/*
 * a64l -- intercept a64l
 */
long a64l(const char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "a64l");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(const char *))actual)(s);
	RECORD(A64L);
	return rc;
}

/* abort -- don't intercept abort */

/*
 * abs -- intercept abs
 */
int abs(int val) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "abs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(val);
	RECORD(ABS);
	return rc;
}

/*
 * access -- intercept access
 */
int access(const char *path,int amode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "access");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, int ))actual)(path, amode);
	RECORD(ACCESS);
	return rc;
}

/*
 * acct -- intercept acct
 */
int acct(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "acct");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(ACCT);
	return rc;
}


/*
 * acl -- intercept acl
 */
#if !defined(__linux)
int acl(const char *pathp,int cmd,int nentries,aclent_t *aclbufp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "acl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, int, int, aclent_t *))actual)(pathp, cmd, nentries,aclbufp);
	RECORD(ACL);
	return rc;
}
#endif /* Not linux */

/*
 * addsev -- intercept addsev
 */
int addsev(int int_val,const char *string) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "addsev");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *))actual)(int_val,string);
	RECORD(ADDSEV);
	return rc;
}

/*
 * addseverity -- intercept addseverity
 */
int addseverity(int severity,const char *string) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "addseverity");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *))actual)(severity,string);
	RECORD(ADDSEVERITY);
	return rc;
}

/*
 * adjtime -- intercept adjtime
 */
#if defined(__sun) 
int adjtime(struct timeval *delta,struct timeval *olddelta) {
#define CAST (int (*)(struct timeval *, struct timeval *))
#elif defined(__linux)
int adjtime(const struct timeval *delta,struct timeval *olddelta) {
#define CAST (int (*)(const struct timeval *, struct timeval *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "adjtime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(delta,olddelta);
	RECORD(ADJTIME);
	return rc;
}

/*
 * alarm -- intercept alarm
 */
unsigned int alarm(unsigned int sec) {
	static void *actual = NULL;
	DECLARE_TIME;
	unsigned int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "alarm");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((unsigned int (*)(unsigned int ))actual)(sec);
	RECORD(ALARM);
	return rc;
}

/*
 * ascftime -- intercept ascftime
 */
int ascftime(char *s,const char *format,const struct tm *timeptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ascftime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, const char *, const struct tm *))actual)(s,format,timeptr);
	RECORD(ASCFTIME);
	return rc;
}

/*
 * asctime -- intercept asctime
 */
char * sctime(const struct tm *tm) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "asctime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char *(*)(const struct tm *))actual)(tm);
	RECORD(ASCTIME);
	return rc;
}

/*
 * atexit -- intercept atexit
 */
int atexit(void (*func)(void)) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "atexit");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void (*)(void)))actual)(func);
	RECORD(ATEXIT);
	return rc;
}

/*
 * atof -- intercept atof
 */
double atof(const char *str) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "atof");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(const char *))actual)(str);
	RECORD(ATOF);
	return rc;
}

/*
 * atoi -- intercept atoi
 */
int atoi(const char *str) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "atoi");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(str);
	RECORD(ATOI);
	return rc;
}

/*
 * atol -- intercept atol
 */
long atol(const char *str) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "atol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(const char *))actual)(str);
	RECORD(ATOL);
	return rc;
}

/*
 * atoll -- intercept atoll
 */
long long atoll(const char *str) {
	static void *actual = NULL;
	DECLARE_TIME;
	long long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "atoll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long long (*)(const char *))actual)(str);
	RECORD(ATOLL);
	return rc;
}


/*
 * attropen -- intercept attropen
 */
int attropen(const char *path, const char *attrpath, 
			int oflag, /* mode_t mode */ ...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, oflag);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "attropen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *, int, int))actual)(path,attrpath, oflag, va_arg(ap, int));
	RECORD(ATTROPEN);
	va_end(ap);
	return rc;
}

/*
 * basename -- intercept basename
 */
char * basename(char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "basename");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(path);
	RECORD(BASENAME);
	return rc;
}

/*
 * bcmp -- intercept bcmp
 */
int bcmp(const void *s1,const void *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "bcmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const void *, const void *, size_t ))actual)(s1,s2,n);
	RECORD(BCMP);
	return rc;
}

/*
 * bcopy -- intercept bcopy
 */
void bcopy(const void *s1,void *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "bcopy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const void *, void *, size_t ))actual)(s1,s2,n);
	RECORD(BCOPY);
	return;
}

/*
 * bindtextdomain -- intercept bindtextdomain
 */
char * bindtextdomain(const char *domainname,const char *dirname) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "bindtextdomain");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(domainname,dirname);
	RECORD(BINDTEXTDOMAIN);
	return rc;
}

/*
 * brk -- intercept brk
 */
int brk(void *endds) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "brk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void *))actual)(endds);
	RECORD(BRK);
	return rc;
}


/*
 * bsearch -- intercept bsearch
 */
void * bsearch(const void *key,const void *base,size_t nel,size_t size,int (*compar)(const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "bsearch");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *,const void *,size_t,size_t,int (*)(const void *,const void *)))actual)(key,base,nel,size,compar);
	RECORD(BSEARCH);
	return rc;
}



/*
 * btowc -- intercept btowc
 */
wint_t btowc(int c) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "btowc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(int ))actual)(c);
	RECORD(BTOWC);
	return rc;
}

/*
 * bzero -- intercept bzero
 */
void bzero(void *s,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "bzero");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void *, size_t ))actual)(s,n);
	RECORD(BZERO);
	return;
}


/*
 * calloc -- intercept calloc
 */
void * calloc(size_t nelem,size_t elsize) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "calloc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(size_t, size_t ))actual)(nelem,elsize);
	RECORD(CALLOC);
	return rc;
}

/*
 * catclose -- intercept catclose
 */
int catclose(nl_catd catd) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "catclose");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(nl_catd))actual)(catd);
	RECORD(CATCLOSE);
	return rc;
}

/*
 * catgets -- intercept catgets
 */
char * catgets(nl_catd catd,int set_num,int msg_num,const char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "catgets");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(nl_catd, int, int, const char *))actual)(catd, set_num, msg_num,s);
	RECORD(CATGETS);
	return rc;
}

/*
 * catopen -- intercept catopen
 */
nl_catd catopen(const char *name,int oflag) {
	static void *actual = NULL;
	DECLARE_TIME;
	nl_catd	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "catopen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((nl_catd (*)(const char *, int ))actual)(name, oflag);
	RECORD(CATOPEN);
	return rc;
}

/*
 * cfgetispeed -- intercept cfgetispeed
 */
speed_t cfgetispeed(const struct termios *termios_p) {
	static void *actual = NULL;
	DECLARE_TIME;
	speed_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "cfgetispeed");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((speed_t (*)(const struct termios *))actual)(termios_p);
	RECORD(CFGETISPEED);
	return rc;
}

/*
 * cfgetospeed -- intercept cfgetospeed
 */
speed_t cfgetospeed(const struct termios *termios_p) {
	static void *actual = NULL;
	DECLARE_TIME;
	speed_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "cfgetospeed");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((speed_t (*)(const struct termios *))actual)(termios_p);
	RECORD(CFGETOSPEED);
	return rc;
}

/*
 * cfsetispeed -- intercept cfsetispeed
 */
int cfsetispeed(struct termios *termios_p,speed_t speed) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "cfsetispeed");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(struct termios *, speed_t))actual)(termios_p,speed);
	RECORD(CFSETISPEED);
	return rc;
}

/*
 * cfsetospeed -- intercept cfsetospeed
 */
int cfsetospeed(struct termios *termios_p,speed_t speed) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "cfsetospeed");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(struct termios *, speed_t))actual)(termios_p,speed);
	RECORD(CFSETOSPEED);
	return rc;
}

/*
 * cftime -- intercept cftime
 */
int cftime(char *s,char *format,const time_t *clock) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "cftime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, char *, const time_t *))actual)(s,format,clock);
	RECORD(CFTIME);
	return rc;
}

/*
 * chdir -- intercept chdir
 */
int chdir(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "chdir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(CHDIR);
	return rc;
}

/*
 * chmod -- intercept chmod
 */
int chmod(const char *path,mode_t mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "chmod");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, mode_t))actual)(path,mode);
	RECORD(CHMOD);
	return rc;
}

/*
 * chown -- intercept chown
 */
int chown(const char *path,uid_t owner,gid_t group) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "chown");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, uid_t, gid_t ))actual)(path,owner,group);
	RECORD(CHOWN);
	return rc;
}

/*
 * chroot -- intercept chroot
 */
int chroot(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "chroot");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(CHROOT);
	return rc;
}

/*
 * clearerr -- don't intercept clearerr, it's can be a define
 */

/*
 * clock -- intercept clock
 */
clock_t clock(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	clock_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "clock");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((clock_t (*)(void))actual)();
	RECORD(CLOCK);
	return rc;
}


/*
 * close -- intercept close
 */
int close(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "close");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(CLOSE);
	return rc;
}

/*
 * closedir -- intercept closedir
 */
int closedir(DIR *dirp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "closedir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(DIR *))actual)(dirp);
	RECORD(CLOSEDIR);
	return rc;
}

/*
 * closefrom -- intercept closefrom
 */
void closefrom(int lowfd) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "closefrom");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(int ))actual)(lowfd);
	RECORD(CLOSEFROM);
	return;
}

/*
 * closelog -- intercept closelog
 */
void closelog(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "closelog");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(CLOSELOG);
	return;
}

/*
 * confstr -- intercept confstr
 */
size_t confstr(int name,char *buf,size_t len) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "confstr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(int, char *, size_t ))actual)(name,buf,len);
	RECORD(CONFSTR);
	return rc;
}

/*
 * creat -- intercept creat
 */
int creat(const char *path,mode_t mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "creat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *,mode_t))actual)(path,mode);
	RECORD(CREAT);
	return rc;
}

/*
 * crypt -- intercept crypt
 */
char * crypt(const char *key,const char *salt) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "crypt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(key,salt);
	RECORD(CRYPT);
	return rc;
}

/*
 * csetcol -- intercept csetcol
 */
int csetcol(int codeset) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "csetcol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(codeset);
	RECORD(CSETCOL);
	return rc;
}

/*
 * csetlen -- intercept csetlen
 */
int csetlen(int codeset) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "csetlen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(codeset);
	RECORD(CSETLEN);
	return rc;
}

/*
 * ctermid -- intercept ctermid
 */
char * ctermid(char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ctermid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(s);
	RECORD(CTERMID);
	return rc;
}

/*
 * ctime -- intercept ctime
 */
char * ctime(const time_t *clock) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ctime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const time_t *))actual)(clock);
	RECORD(CTIME_);
	return rc;
}

/*
 * cuserid -- intercept cuserid
 */
char * cuserid(char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "cuserid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(s);
	RECORD(CUSERID);
	return rc;
}

/*
 * dcgettext -- intercept dcgettext
 */
char * dcgettext(const char *domainname,const char *msgid,const int category) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dcgettext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *, const int ))actual)(domainname,msgid, category);
	RECORD(DCGETTEXT);
	return rc;
}

/*
 * dcngettext -- intercept dcngettext
 */
char * dcngettext(const char *domainname,const char *msgid1,const char *msgid2,unsigned long int n,int category) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dcngettext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *, const char *, unsigned long int, int ))actual)(domainname,msgid1,msgid2, n, category);
	RECORD(DCNGETTEXT);
	return rc;
}


/*
 * dgettext -- intercept dgettext
 */
char * dgettext(const char *domainname,const char *msgid) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dgettext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(domainname,msgid);
	RECORD(DGETTEXT);
	return rc;
}


/*
 * difftime -- intercept difftime
 */
double difftime(time_t time1,time_t time0) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "difftime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(time_t, time_t ))actual)(time1,time0);
	RECORD(DIFFTIME);
	return rc;
}

/*
 * directio -- intercept directio
 */
int directio(int fildes,int advice) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "directio");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int ))actual)(fildes, advice);
	RECORD(DIRECTIO);
	return rc;
}

/*
 * dirname -- intercept dirname
 */
char * dirname(char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dirname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(path);
	RECORD(DIRNAME);
	return rc;
}


/*
 * div -- intercept div
 */
div_t div(int numer,int denom) {
	static void *actual = NULL;
	DECLARE_TIME;
	div_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "div");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((div_t (*)(int,int))actual)(numer,denom);
	RECORD(DIV);
	return rc;
}



/*
 * dngettext -- intercept dngettext
 */
char * dngettext(const char *domainname,const char *msgid1,const char *msgid2,unsigned long int n) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dngettext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *, const char *, unsigned long int))actual)(domainname,msgid1,msgid2, n);
	RECORD(DNGETTEXT);
	return rc;
}

/*
 * drand48 -- intercept drand48
 */
double drand48(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "drand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(void))actual)();
	RECORD(DRAND48);
	return rc;
}

/*
 * dup -- intercept dup
 */
int dup(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dup");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(DUP);
	return rc;
}

/*
 * dup2 -- intercept dup2
 */
int dup2(int fildes,int fildes2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "dup2");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int ))actual)(fildes, fildes2);
	RECORD(DUP2);
	return rc;
}

/*
 * econvert -- intercept econvert
 */
char * econvert(double value,int ndigit,int *decpt,int *sign,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "econvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(double, int, int *, int *, char *))actual)(value, ndigit,decpt,sign,buf);
	RECORD(ECONVERT);
	return rc;
}

/*
 * ecvt -- intercept ecvt
 */
char * ecvt(double value,int ndigit,int *decpt,int *sign) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ecvt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(double, int, int *, int *))actual)(value, ndigit,decpt,sign);
	RECORD(ECVT);
	return rc;
}

/*
 * encrypt -- intercept encrypt
 */
void encrypt(char block[64],int edflag) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "encrypt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(char, int ))actual)(block[64], edflag);
	RECORD(ENCRYPT);
	return;
}

/*
 * endgrent -- intercept endgrent
 */
void endgrent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "endgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(ENDGRENT);
	return;
}

/*
 * endnetgrent -- intercept endnetgrent
 */
int endnetgrent(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "endnetgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(ENDNETGRENT);
	return rc;
}

/*
 * endpwent -- intercept endpwent
 */
void endpwent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "endpwent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(ENDPWENT);
	return;
}

/*
 * endspent -- intercept endspent
 */
void endspent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "endspent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(ENDSPENT);
	return;
}

/*
 * endutent -- intercept endutent
 */
void endutent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "endutent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(ENDUTENT);
	return;
}

/*
 * endutxent -- intercept endutxent
 */
void endutxent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "endutxent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(ENDUTXENT);
	return;
}

/*
 * erand48 -- intercept erand48
 */
double erand48(unsigned short xi[3] ) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "erand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(unsigned short ))actual)(xi[3]);
	RECORD(ERAND48);
	return rc;
}

/*
 * euccol -- intercept euccol
 */
int euccol(const unsigned char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "euccol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const unsigned char *))actual)(s);
	RECORD(EUCCOL);
	return rc;
}

/*
 * euclen -- intercept euclen
 */
int euclen(const unsigned char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "euclen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const unsigned char *s))actual)(s);
	RECORD(EUCLEN);
	return rc;
}

/*
 * eucscol -- intercept eucscol
 */
int eucscol(const unsigned char *str) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "eucscol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const unsigned char *))actual)(str);
	RECORD(EUCSCOL);
	return rc;
}

/*
 * execl -- don't intercept execl or its friends.
 */


/*
 * exit -- don't intercept exit or _exit.
 */


/*
 * facl -- intercept facl
 */
#if !defined(__linux)
int facl(int fildes,int cmd,int nentries,aclent_t *aclbufp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "facl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, int, aclent_t *))actual)(fildes, cmd, nentries,aclbufp);
	RECORD(FACL);
	return rc;
}
#endif /* Not linux */

/*
 * fattach -- intercept fattach
 */
int fattach(int fildes,const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fattach");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *))actual)(fildes,path);
	RECORD(FATTACH);
	return rc;
}

/*
 * fchdir -- intercept fchdir
 */
int fchdir(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fchdir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(FCHDIR);
	return rc;
}

/*
 * fchmod -- intercept fchmod
 */
int fchmod(int fildes,mode_t mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fchmod");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, mode_t))actual)(fildes,mode);
	RECORD(FCHMOD);
	return rc;
}

/*
 * fchown -- intercept fchown
 */
int fchown(int fildes,uid_t owner,gid_t group) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fchown");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, uid_t, gid_t ))actual)(fildes,owner,group);
	RECORD(FCHOWN);
	return rc;
}

/*
 * fchownat -- intercept fchownat
 */
int fchownat(int fildes,const char *path,uid_t owner,gid_t group,int flag) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fchownat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, uid_t, gid_t, int ))actual)(fildes,path,owner,group, flag);
	RECORD(FCHOWNAT);
	return rc;
}

/*
 * fchroot -- intercept fchroot
 */
int fchroot(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fchroot");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(FCHROOT);
	return rc;
}

/*
 * fclose -- intercept fclose
 */
int fclose(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fclose");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(stream);
	RECORD(FCLOSE);
	return rc;
}


/*
 * fcntl -- intercept fcntl
 */
int fcntl(int fildes, int cmd, /* arg */ ...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, cmd);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fcntl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, void *))actual)(fildes, cmd, va_arg(ap, void *));
	RECORD(FCNTL);
	va_end(ap);
	return rc;
}


/*
 * fconvert -- intercept fconvert
 */
char * fconvert(double value,int ndigit,int *decpt,int *sign,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(double, int, int *, int *, char *))actual)(value, ndigit,decpt,sign,buf);
	RECORD(FCONVERT);
	return rc;
}

/*
 * fcvt -- intercept fcvt
 */
char * fcvt(double value,int ndigit,int *decpt,int *sign) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fcvt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(double, int, int *, int *))actual)(value, ndigit,decpt,sign);
	RECORD(FCVT);
	return rc;
}

/*
 * fdetach -- intercept fdetach
 */
int fdetach(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fdetach");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(FDETACH);
	return rc;
}

/*
 * fdopen -- intercept fdopen
 */
FILE * fdopen(int fildes,const char *mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	FILE *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fdopen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((FILE * (*)(int, const char *))actual)(fildes,mode);
	RECORD(FDOPEN);
	return rc;
}

/*
 * fdopendir -- intercept fdopendir
 */
DIR * fdopendir(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	DIR *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fdopendir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((DIR * (*)(int ))actual)(fildes);
	RECORD(FDOPENDIR);
	return rc;
}

/*
 * fdwalk -- intercept fdwalk
 */
int fdwalk(int (*func)(void *,int),void *cd) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fdwalk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int (*)(void *,int),void *))actual)(func,cd);
	RECORD(FDWALK);
	return rc;
}



/*
 * feof -- don't intercept feof, it can be a define
 * ferror -- ditto
 */


/*
 * fflush -- intercept fflush
 */
int fflush(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fflush");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(stream);
	RECORD(FFLUSH);
	return rc;
}

/*
 * ffs -- intercept ffs
 */
int ffs(int i) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ffs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const int))actual)(i);
	RECORD(FFS);
	return rc;
}

/*
 * fgetc -- intercept fgetc
 */
int fgetc(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(stream);
	RECORD(FGETC);
	return rc;
}

/*
 * fgetgrent -- intercept fgetgrent
 */
struct group * fgetgrent(FILE *f) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct group *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct group * (*)(FILE *))actual)(f);
	RECORD(FGETGRENT);
	return rc;
}

/*
 * fgetpos -- intercept fgetpos
 */
int fgetpos(FILE *stream,fpos_t *pos) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetpos");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, fpos_t *))actual)(stream,pos);
	RECORD(FGETPOS);
	return rc;
}

/*
 * fgetpwent -- intercept fgetpwent
 */
struct passwd * fgetpwent(FILE *f) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct passwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetpwent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct passwd * (*)(FILE *))actual)(f);
	RECORD(FGETPWENT);
	return rc;
}

/*
 * fgets -- intercept fgets
 */
char * fgets(char *s,int n,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgets");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, int, FILE *))actual)(s, n,stream);
	RECORD(FGETS);
	return rc;
}

/*
 * fgetspent -- intercept fgetspent
 */
struct spwd * fgetspent(FILE *fp) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct spwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetspent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct spwd * (*)(FILE *))actual)(fp);
	RECORD(FGETSPENT);
	return rc;
}

/*
 * fgetwc -- intercept fgetwc
 */
wint_t fgetwc(FILE* stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetwc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(FILE*))actual)(stream);
	RECORD(FGETWC);
	return rc;
}

/*
 * fgetws -- intercept fgetws
 */
wchar_t * fgetws(wchar_t *ws,int n,FILE *fp) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fgetws");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, int, FILE *))actual)(ws, n, fp);
	RECORD(FGETWS);
	return rc;
}

/*
 * fileno -- don't intercept fileno, it can be a define
 */

/*
 * finite -- intercept finite
 */
int finite(double dsrc) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "finite");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(double ))actual)(dsrc);
	RECORD(FINITE);
	return rc;
}

/*
 * flockfile -- intercept flockfile
 */
void flockfile(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "flockfile");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(FILE *))actual)(stream);
	RECORD(FLOCKFILE);
	return;
}

/*
 * fmtmsg -- intercept fmtmsg
 */
int fmtmsg(long classification,const char *label,int severity,const char *text,const char *action,const char *tag) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fmtmsg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(long, const char *, int, const char *, const char *, const char *))actual)(classification,label, severity,text,action,tag);
	RECORD(FMTMSG);
	return rc;
}

/*
 * fnmatch -- intercept fnmatch
 */
int fnmatch(const char *pattern,const char *string,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fnmatch");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *, int ))actual)(pattern,string, flags);
	RECORD(FNMATCH);
	return rc;
}

/*
 * fopen -- intercept fopen
 */
FILE * fopen(const char *filename,const char *mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	FILE *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fopen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((FILE * (*)(const char *, const char *))actual)(filename,mode);
	RECORD(FOPEN);
	return rc;
}

/*
 * fork -- intercept fork
 */
pid_t fork(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fork");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(FORK);
	return rc;
}

/*
 * fork1 -- intercept fork1
 */
pid_t fork1(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fork1");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(FORK1);
	return rc;
}

/*
 * fpathconf -- intercept fpathconf
 */
long fpathconf(int fildes,int name) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpathconf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(int, int ))actual)(fildes, name);
	RECORD(FPATHCONF);
	return rc;
}

/*
 * fpclass -- intercept fpclass
 */
#if !defined(__linux)
fpclass_t fpclass(double dsrc) {
	static void *actual = NULL;
	DECLARE_TIME;
	fpclass_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpclass");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fpclass_t (*)(double))actual)(dsrc);
	RECORD(FPCLASS);
	return rc;
}
#endif /* Not linux */

/*
 * fpgetmask -- intercept fpgetmask
 */
#if !defined(__linux)
fp_except fpgetmask(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	fp_except	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpgetmask");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fp_except (*)(void))actual)();
	RECORD(FPGETMASK);
	return rc;
}
#endif /* Not linux */

/*
 * fpgetround -- intercept fpgetround
 */
#if !defined(__linux)
fp_rnd fpgetround(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	fp_rnd	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpgetround");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fp_rnd (*)(void))actual)();
	RECORD(FPGETROUND);
	return rc;
}
#endif /* Not linux */

/*
 * fpgetsticky -- intercept fpgetsticky
 */
#if !defined(__linux)
fp_except fpgetsticky(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	fp_except	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpgetsticky");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fp_except (*)(void))actual)();
	RECORD(FPGETSTICKY);
	return rc;
}
#endif /* Not linux */

/*
 * fprintf -- intercept fprintf, call underlying vfprintf
 */
int fprintf(FILE *stream,const char *format, ...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const char *, va_list))actual)(stream, format, ap);
	RECORD(FPRINTF);
	va_end(ap);
	return rc;
}



/*
 * fpsetmask -- intercept fpsetmask
 */
#if !defined(__linux)
fp_except fpsetmask(fp_except mask) {
	static void *actual = NULL;
	DECLARE_TIME;
	fp_except	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpsetmask");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fp_except (*)(fp_except))actual)(mask);
	RECORD(FPSETMASK);
	return rc;
}
#endif /* Not linux */
/*
 * fpsetround -- intercept fpsetround
 */
#if !defined(__linux)
fp_rnd fpsetround(fp_rnd rnd_dir) {
	static void *actual = NULL;
	DECLARE_TIME;
	fp_rnd	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpsetround");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fp_rnd (*)(fp_rnd ))actual)(rnd_dir);
	RECORD(FPSETROUND);
	return rc;
}
#endif /* Not linux */

/*
 * fpsetsticky -- intercept fpsetsticky
 */
#if !defined(__linux)
fp_except fpsetsticky(fp_except sticky) {
	static void *actual = NULL;
	DECLARE_TIME;
	fp_except	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fpsetsticky");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((fp_except (*)(fp_except))actual)(sticky);
	RECORD(FPSETSTICKY);
	return rc;
}
#endif /* Not linux */

/*
 * fputc -- intercept fputc
 */
int fputc(int c,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fputc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, FILE *))actual)(c,stream);
	RECORD(FPUTC);
	return rc;
}

/*
 * fputs -- intercept fputs
 */
int fputs(const char *s,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fputs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *s, FILE *))actual)(s,stream);
	RECORD(FPUTS);
	return rc;
}

/*
 * fputwc -- intercept fputwc
 */
wint_t fputwc(wchar_t wc,FILE*stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fputwc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wchar_t, FILE*))actual)(wc,stream);
	RECORD(FPUTWC);
	return rc;
}

/*
 * fputws -- intercept fputws
 */
int fputws(const wchar_t *s,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fputws");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *s, FILE *))actual)(s,stream);
	RECORD(FPUTWS);
	return rc;
}

/*
 * fread -- intercept fread
 */
size_t fread(void *ptr,size_t size,size_t nitems,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fread");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(void *, size_t, size_t, FILE *))actual)(ptr,size,nitems,stream);
	RECORD(FREAD);
	return rc;
}

/*
 * free -- intercept free
 */
void free(void *ptr) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "free");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void *))actual)(ptr);
	RECORD(FREE);
	return;
}

/*
 * freopen -- intercept freopen
 */
FILE * freopen(const char *filename,const char *mode,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	FILE *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "freopen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((FILE * (*)(const char *, const char *, FILE *))actual)(filename,mode,stream);
	RECORD(FREOPEN);
	return rc;
}

/*
 * frexp -- intercept frexp
 */
double frexp(double num,int *exp) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "frexp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(double, int *))actual)(num,exp);
	RECORD(FREXP);
	return rc;
}


/*
 * fscanf -- intercept fscanf, call underlying vfscanf
 */
int fscanf(FILE*stream,const char *format,...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *,const char *, va_list))actual)(stream,format,ap);
	RECORD(FSCANF);
	va_end(ap);
	return rc;
}


/*
 * fseek -- intercept fseek
 */
int fseek(FILE *stream,long offset,int whence) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fseek");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, long, int ))actual)(stream,offset, whence);
	RECORD(FSEEK);
	return rc;
}

/*
 * fseeko -- intercept fseeko
 */
int fseeko(FILE *stream,off_t offset,int whence) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fseeko");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, off_t, int ))actual)(stream,offset, whence);
	RECORD(FSEEKO);
	return rc;
}

/*
 * fsetpos -- intercept fsetpos
 */
int fsetpos(FILE *stream,const fpos_t *pos) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fsetpos");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const fpos_t *))actual)(stream,pos);
	RECORD(FSETPOS);
	return rc;
}

/*
 * fstat -- intercept fstat
 */
int fstat(int fildes,struct stat *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fstat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct stat *))actual)(fildes,buf);
	RECORD(FSTAT);
	return rc;
}

/*
 * fstatat -- intercept fstatat
 */
int fstatat(int fildes,const char *path,struct stat *buf,int flag) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fstatat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, struct stat *, int ))actual)(fildes,path,buf, flag);
	RECORD(FSTATAT);
	return rc;
}

/*
 * fstatvfs -- intercept fstatvfs
 */
int fstatvfs(int fildes,struct statvfs *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fstatvfs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct statvfs *))actual)(fildes,buf);
	RECORD(FSTATVFS);
	return rc;
}

/*
 * fsync -- intercept fsync
 */
int fsync(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fsync");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(FSYNC);
	return rc;
}

/*
 * ftell -- intercept ftell
 */
long ftell(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftell");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(FILE *))actual)(stream);
	RECORD(FTELL);
	return rc;
}

/*
 * ftello -- intercept ftello
 */
off_t ftello(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	off_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftello");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((off_t (*)(FILE *))actual)(stream);
	RECORD(FTELLO);
	return rc;
}

/*
 * ftime -- intercept ftime
 */
int ftime(struct timeb *tp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(struct timeb *))actual)(tp);
	RECORD(FTIME);
	return rc;
}

/*
 * ftok -- intercept ftok
 */
key_t ftok(const char *path,int id) {
	static void *actual = NULL;
	DECLARE_TIME;
	key_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftok");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((key_t (*)(const char *, int ))actual)(path, id);
	RECORD(FTOK);
	return rc;
}

/*
 * ftruncate -- intercept ftruncate
 */
int ftruncate(int fildes,off_t length) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftruncate");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, off_t ))actual)(fildes,length);
	RECORD(FTRUNCATE);
	return rc;
}

/*
 * ftrylockfile -- intercept ftrylockfile
 */
int ftrylockfile(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftrylockfile");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(stream);
	RECORD(FTRYLOCKFILE);
	return rc;
}

#ifdef FTW_OK
/*
 * ftw -- intercept ftw
 */
int ftw(const char *path,int (*fn)(const char *,const struct stat *,int),int depth) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ftw");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *,int (*)(const char *,const struct stat *,int),int))actual)(path,fn,depth);
	RECORD(FTW);
	return rc;
}
#endif


/*
 * funlockfile -- intercept funlockfile
 */
void funlockfile(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "funlockfile");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(FILE *))actual)(stream);
	RECORD(FUNLOCKFILE);
	return;
}

/*
 * futimesat -- intercept futimesat
 */
int futimesat(int fildes,const char *path,const struct timeval times[2]) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "futimesat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, const struct timeval[2]))actual)(fildes,path,times);
	RECORD(FUTIMESAT);
	return rc;
}

/*
 * fwide -- intercept fwide
 */
int fwide(FILE *stream,int mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fwide");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, int ))actual)(stream, mode);
	RECORD(FWIDE);
	return rc;
}


/*
 * fwprintf -- intercept fwprintf, call underlying vfwprintf
 */
int fwprintf(FILE *stream,const wchar_t *format,...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfwprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *,const wchar_t *, va_list))actual)(stream,format,ap);
	RECORD(FWPRINTF);
	va_end(ap);
	return rc;
}




/*
 * fwrite -- intercept fwrite
 */
size_t fwrite(const void *ptr,size_t size,size_t nitems,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "fwrite");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const void *, size_t, size_t, FILE *))actual)(ptr,size,nitems,stream);
	RECORD(FWRITE);
	return rc;
}


/*
 * fwscanf -- intercept fwscanf, call underlying vfwscanf
 */
int fwscanf(FILE *stream,const wchar_t *format,...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap,format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfwscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const wchar_t *, va_list))actual)(stream,format,ap);
	RECORD(FWSCANF);
	va_end(ap);
	return rc;
}


/*
 * gconvert -- intercept gconvert
 */
char * gconvert(double value,int ndigit,int trailing,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(double, int, int, char *))actual)(value, ndigit, trailing,buf);
	RECORD(GCONVERT);
	return rc;
}

/*
 * gcvt -- intercept gcvt
 */
char * gcvt(double value,int ndigit,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gcvt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(double, int, char *))actual)(value, ndigit,buf);
	RECORD(GCVT);
	return rc;
}

/*
 * getacct -- intercept getacct
 */
size_t getacct(idtype_t idtype,id_t id,void *buf,size_t bufsize) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getacct");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(idtype_t, id_t, void *, size_t ))actual)(idtype,id,buf,bufsize);
	RECORD(GETACCT);
	return rc;
}

/*
 * getc -- don't intercept getc, it can be a define
 * getchar -- ditto
 */

/*
 * getcontext -- intercept getcontext
 */
int getcontext(ucontext_t *ucp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getcontext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(ucontext_t *))actual)(ucp);
	RECORD(GETCONTEXT_);
	return rc;
}

/*
 * getcpuid -- intercept getcpuid
 */
#if !defined(__linux)
processorid_t getcpuid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	processorid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getcpuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((processorid_t (*)(void))actual)();
	RECORD(GETCPUID);
	return rc;
}
#endif /* Not linux */

/*
 * getcwd -- intercept getcwd
 */
char * getcwd(char *buf,size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getcwd");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, size_t))actual)(buf,size);
	RECORD(GETCWD);
	return rc;
}

/*
 * getdate -- intercept getdate
 */
struct tm * getdate(const char *string) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct tm *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getdate");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct tm * (*)(const char *))actual)(string);
	RECORD(GETDATE);
	return rc;
}

/*
 * getdents -- intercept getdents
 */
int getdents(int fildes,struct dirent *buf,size_t nbyte) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getdents");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct dirent *, size_t ))actual)(fildes,buf,nbyte);
	RECORD(GETDENTS);
	return rc;
}

/*
 * getdtablesize -- intercept getdtablesize
 */
int getdtablesize(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getdtablesize");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(GETDTABLESIZE);
	return rc;
}

/*
 * getegid -- intercept getegid
 */
gid_t getegid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	gid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getegid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((gid_t (*)(void))actual)();
	RECORD(GETEGID);
	return rc;
}


/*
 * getenv -- intercept getenv
 */
char * getenv(const char *name) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getenv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(name);
	RECORD(GETENV);
	return rc;
}


/*
 * geteuid -- intercept geteuid
 */
uid_t geteuid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	uid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "geteuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((uid_t (*)(void))actual)();
	RECORD(GETEUID);
	return rc;
}

/*
 * getexecname -- intercept getexecname
 */
const char * getexecname(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	const char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getexecname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((const char * (*)(void))actual)();
	RECORD(GETEXECNAME);
	return rc;
}

/*
 * getextmntent -- intercept getextmntent
 */
#if !defined(__linux)
int getextmntent(FILE *fp,struct extmnttab *mp, uint_t len) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getextmntent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct extmnttab *, uint_t ))actual)(fp,mp, len);
	RECORD(GETEXTMNTENT);
	return rc;
}
#endif /* Not linux */

/*
 * getgid -- intercept getgid
 */
gid_t getgid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	gid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getgid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((gid_t (*)(void))actual)();
	RECORD(GETGID);
	return rc;
}

/*
 * getgrent -- intercept getgrent
 */
struct group * getgrent(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct group *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct group * (*)(void))actual)();
	RECORD(GETGRENT);
	return rc;
}

/*
 * getgrgid -- intercept getgrgid
 */
struct group * getgrgid(gid_t gid) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct group *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getgrgid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct group * (*)(gid_t))actual)(gid);
	RECORD(GETGRGID);
	return rc;
}

/*
 * getgrnam -- intercept getgrnam
 */
struct group * getgrnam(const char *name) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct group *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getgrnam");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct group * (*)(const char *))actual)(name);
	RECORD(GETGRNAM);
	return rc;
}

/*
 * getgroups -- intercept getgroups
 */
int getgroups(int gidsetsize,gid_t *grouplist) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getgroups");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, gid_t *))actual)(gidsetsize,grouplist);
	RECORD(GETGROUPS);
	return rc;
}

/*
 * gethomelgroup -- intercept gethomelgroup
 */
#if !defined(__linux)
lgrpid_t gethomelgroup(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	lgrpid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gethomelgroup");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	/* Lint thinks this is a 64-to-32-bit assignment. However, rc is properly declared lgrpid_t */
	rc = ((lgrpid_t (*)(void))actual)();
	RECORD(GETHOMELGROUP);
	return rc;
}
#endif /* Not linux */

/*
 * gethostid -- intercept gethostid
 */
long gethostid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gethostid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(void))actual)();
	RECORD(GETHOSTID);
	return rc;
}

/*
 * gethostname -- intercept gethostname
 */
#undef CAST
#if defined(__sun)
int gethostname(char *name,int namelen) {
#define CAST (int (*)(char *, int ))
#elif defined(__linux)
int gethostname(char *name, size_t namelen) {
#define CAST (int (*)(char *, size_t ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gethostname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(name, namelen);
	RECORD(GETHOSTNAME);
	return rc;
}

/*
 * gethrtime -- don't intercept gethrtime, we use it!
 *	Intercepting it is also wasted effort, as it's
 *	really only about four instructions long...
 */

/*
 * gethrvtime -- intercept gethrvtime
 */
#if !defined(__linux)
hrtime_t gethrvtime(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	hrtime_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gethrvtime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((hrtime_t (*)(void))actual)();
	RECORD(GETHRVTIME);
	return rc;
}
#endif /* Not linux */

/*
 * getitimer -- intercept getitimer
 */
int getitimer(int which,struct itimerval *value) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getitimer");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct itimerval *))actual)(which,value);
	RECORD(GETITIMER);
	return rc;
}

/*
 * getloadavg -- intercept getloadavg
 */
int getloadavg(double *loadavg, int nelem) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getloadavg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(double *, int ))actual)(loadavg, nelem);
	RECORD(GETLOADAVG);
	return rc;
}

/*
 * getlogin -- intercept getlogin
 */
char * getlogin(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getlogin");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(void))actual)();
	RECORD(GETLOGIN);
	return rc;
}

/*
 * getmntany -- intercept getmntany
 */
#if !defined(__linux)
int getmntany(FILE *fp,struct mnttab *mp,struct mnttab *mpref) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getmntany");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct mnttab *, struct mnttab *))actual)(fp,mp,mpref);
	RECORD(GETMNTANY);
	return rc;
}
#endif /* Not linux */

/*
 * getmntent -- intercept getmntent
 */
#if !defined(__linux)
int getmntent(FILE *fp,struct mnttab *mp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getmntent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct mnttab *))actual)(fp,mp);
	RECORD(GETMNTENT);
	return rc;
}
#endif /* Not linux */

/*
 * getmsg -- intercept getmsg
 */
int getmsg(int fildes,struct strbuf *ctlptr,struct strbuf *dataptr,int *flagsp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getmsg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int,struct strbuf *,struct strbuf *,int *))actual)(fildes,ctlptr,dataptr,flagsp);
	RECORD(GETMSG);
	return rc;
}



/*
 * getnetgrent -- intercept getnetgrent
 */
int getnetgrent(char **machinep,char **userp,char **domainp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getnetgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char **, char **, char **))actual)(machinep,userp,domainp);
	RECORD(GETNETGRENT);
	return rc;
}


/*
 * getopt -- intercept getopt
 */
int getopt(int argc,char * const *argv,const char *optstring) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getopt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, char * const *, const char *))actual)(argc,argv,optstring);
	RECORD(GETOPT);
	return rc;
}


/*
 * getpagesize -- intercept getpagesize
 */
int getpagesize(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpagesize");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(GETPAGESIZE);
	return rc;
}


/*
 * getpagesizes -- intercept getpagesizes
 */
int getpagesizes(size_t *pagesize, int nelem) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpagesizes");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(size_t *, int ))actual)(pagesize, nelem);
	RECORD(GETPAGESIZES);
	return rc;
}


/*
 * getpass -- intercept getpass
 */
char * getpass(const char *prompt) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpass");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(prompt);
	RECORD(GETPASS);
	return rc;
}

/*
 * getpassphrase -- intercept getpassphrase
 */
char * getpassphrase(const char *prompt) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpassphrase");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(prompt);
	RECORD(GETPASSPHRASE);
	return rc;
}

/*
 * getpgid -- intercept getpgid
 */
pid_t getpgid(pid_t pid) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpgid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(pid_t))actual)(pid);
	RECORD(GETPGID);
	return rc;
}

/*
 * getpgrp -- intercept getpgrp
 */
pid_t getpgrp(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpgrp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(GETPGRP);
	return rc;
}

/*
 * getpid -- intercept getpid
 */
pid_t getpid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(GETPID_);
	return rc;
}

/*
 * getpmsg -- intercept getpmsg
 */
int getpmsg(int fildes,struct strbuf *ctlptr,struct strbuf *dataptr,int *bandp,int *flagsp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpmsg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct strbuf *, struct strbuf *, int *, int *))actual)(fildes,ctlptr,dataptr,bandp,flagsp);
	RECORD(GETPMSG);
	return rc;
}

/*
 * getppid -- intercept getppid
 */
pid_t getppid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getppid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(GETPPID);
	return rc;
}

/*
 * getpriority -- intercept getpriority
 */
int getpriority(int which,id_t who) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpriority");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, id_t ))actual)(which,who);
	RECORD(GETPRIORITY);
	return rc;
}

/*
 * getprojid -- intercept getprojid
 */
#if !defined(__linux)
projid_t getprojid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	projid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getprojid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((projid_t (*)(void))actual)();
	RECORD(GETPROJID);
	return rc;
}
#endif /* Not linux */

/*
 * getpw -- intercept getpw
 */
int getpw(uid_t uid,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpw");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(uid_t, char *))actual)(uid,buf);
	RECORD(GETPW);
	return rc;
}

/*
 * getpwent -- intercept getpwent
 */
struct passwd * getpwent(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct passwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpwent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct passwd * (*)(void))actual)();
	RECORD(GETPWENT);
	return rc;
}

/*
 * getpwnam -- intercept getpwnam
 */
struct passwd * getpwnam(const char *name) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct passwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpwnam");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct passwd * (*)(const char *))actual)(name);
	RECORD(GETPWNAM);
	return rc;
}

/*
 * getpwuid -- intercept getpwuid
 */
struct passwd * getpwuid(uid_t uid) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct passwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getpwuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct passwd * (*)(uid_t))actual)(uid);
	RECORD(GETPWUID);
	return rc;
}

/*
 * getrctl -- intercept getrctl
 */
#if defined(__sun)
int getrctl(const char *controlname,rctlblk_t *old_blk,rctlblk_t *new_blk, int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getrctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, rctlblk_t *, rctlblk_t *, uint_t ))actual)(controlname,old_blk,new_blk,flags);
	RECORD(GETRCTL);
	return rc;
}
#endif 

/*
 * getrlimit -- intercept getrlimit
 */
int getrlimit(int resource,struct rlimit *rlp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getrlimit");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct rlimit *))actual)(resource,rlp);
	RECORD(GETRLIMIT);
	return rc;
}

/*
 * getrusage -- intercept getrusage
 */
int getrusage(int who,struct rusage *r_usage) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getrusage");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct rusage *))actual)(who,r_usage);
	RECORD(GETRUSAGE);
	return rc;
}

/*
 * gets -- intercept gets
 */
char * gets(char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gets");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(s);
	RECORD(GETS);
	return rc;
}

/*
 * getsid -- intercept getsid
 */
pid_t getsid(pid_t pid) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getsid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(pid_t))actual)(pid);
	RECORD(GETSID);
	return rc;
}

/*
 * getspent -- intercept getspent
 */
struct spwd * getspent(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct spwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getspent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct spwd * (*)(void))actual)();
	RECORD(GETSPENT);
	return rc;
}

/*
 * getspnam -- intercept getspnam
 */
struct spwd * getspnam(const char *name) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct spwd *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getspnam");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct spwd * (*)(const char *))actual)(name);
	RECORD(GETSPNAM);
	return rc;
}

/*
 * getsubopt -- intercept getsubopt
 */
int getsubopt(char **optionp,char * const *tokens,char **valuep) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getsubopt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char **, char * const *, char **))actual)(optionp,tokens,valuep);
	RECORD(GETSUBOPT);
	return rc;
}

/*
 * gettaskid -- intercept gettaskid
 */
#if defined(__sun)
taskid_t gettaskid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	taskid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gettaskid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((taskid_t (*)(void))actual)();
	RECORD(GETTASKID);
	return rc;
}
#endif

/*
 * gettext -- intercept gettext
 */
char * gettext(const char *msgid) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gettext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(msgid);
	RECORD(GETTEXT);
	return rc;
}

/*
 * gettimeofday -- don't intercept gettimeofday, it's used
 *	in every interceptor, in versions not using gethrtime.
 */

/*
 * gettxt -- intercept gettxt
 */
char * gettxt(const char *msgid,const char *dflt_str) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gettxt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(msgid,dflt_str);
	RECORD(GETTXT);
	return rc;
}

/*
 * getuid -- intercept getuid
 */
uid_t getuid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	uid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((uid_t (*)(void))actual)();
	RECORD(GETUID);
	return rc;
}

/*
 * getustack -- intercept getustack
 */
int getustack(stack_t **spp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getustack");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(stack_t **))actual)(spp);
	RECORD(GETUSTACK_);
	return rc;
}

/*
 * getutent -- intercept getutent
 */
struct utmp * getutent(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmp *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmp * (*)(void))actual)();
	RECORD(GETUTENT);
	return rc;
}

/*
 * getutid -- intercept getutid
 */
struct utmp * getutid(const struct utmp *id) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmp *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmp * (*)(const struct utmp *))actual)(id);
	RECORD(GETUTID);
	return rc;
}

/*
 * getutline -- intercept getutline
 */
struct utmp * getutline(const struct utmp *line) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmp *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutline");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmp * (*)(const struct utmp *))actual)(line);
	RECORD(GETUTLINE);
	return rc;
}

/*
 * getutmp -- intercept getutmp
 */
void getutmp(const struct utmpx * utmpx,struct utmp *utmp) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const struct utmpx *, struct utmp *))actual)(utmpx,utmp);
	RECORD(GETUTMP);
	return;
}

/*
 * getutmpx -- intercept getutmpx
 */
void getutmpx(const struct utmp *utmp,struct utmpx *utmpx) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutmpx");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const struct  utmp *, struct utmpx *))actual)(utmp,utmpx);
	RECORD(GETUTMPX);
	return;
}

/*
 * getutxent -- intercept getutxent
 */
struct utmpx * getutxent(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmpx *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutxent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmpx * (*)(void))actual)();
	RECORD(GETUTXENT);
	return rc;
}

/*
 * getutxid -- intercept getutxid
 */
struct utmpx * getutxid(const struct utmpx *id) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmpx *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutxid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmpx * (*)(const struct utmpx *))actual)(id);
	RECORD(GETUTXID);
	return rc;
}

/*
 * getutxline -- intercept getutxline
 */
struct utmpx * getutxline(const struct utmpx *line) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmpx *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getutxline");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmpx * (*)(const struct utmpx *))actual)(line);
	RECORD(GETUTXLINE);
	return rc;
}

/*
 * getvfsany -- intercept getvfsany. Vfstab functions are Sun-specific.
 */
#if defined(__sun)
int getvfsany(FILE * fp,struct vfstab *vp,struct vfstab *vref) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getvfsany");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct vfstab *, struct vfstab *))actual)(fp,vp,vref);
	RECORD(GETVFSANY);
	return rc;
}
#endif

/*
 * getvfsent -- intercept getvfsent
 */
#if defined(__sun)
int getvfsent(FILE *fp,struct vfstab *vp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getvfsent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct vfstab *))actual)(fp,vp);
	RECORD(GETVFSENT);
	return rc;
}
#endif

/*
 * getvfsfile -- intercept getvfsfile
 */
#if defined(__sun)
int getvfsfile(FILE *fp,struct vfstab *vp,char *file) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getvfsfile");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct vfstab *, char *))actual)(fp,vp,file);
	RECORD(GETVFSFILE);
	return rc;
}
#endif

/*
 * getvfsspec -- intercept getvfsspec
 */
#if defined(__sun)
int getvfsspec(FILE *fp ,struct vfstab *vp,char *spec) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getvfsspec");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, struct vfstab *, char *))actual)(fp,vp,spec);
	RECORD(GETVFSSPEC);
	return rc;
}
#endif

/*
 * getw -- intercept getw
 */
int getw(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getw");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(stream);
	RECORD(GETW);
	return rc;
}

/*
 * getwc -- intercept getwc
 */
wint_t getwc(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getwc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(FILE *))actual)(stream);
	RECORD(GETWC);
	return rc;
}

/*
 * getwchar -- intercept getwchar
 */
wint_t getwchar(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getwchar");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(void))actual)();
	RECORD(GETWCHAR);
	return rc;
}

/*
 * getwd -- intercept getwd
 */
char * getwd(char *path_name) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getwd");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(path_name);
	RECORD(GETWD);
	return rc;
}

/*
 * getwidth -- intercept getwidth
 */
#if !defined(__linux)
void getwidth(eucwidth_t *ptr) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getwidth");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(eucwidth_t *))actual)(ptr);
	RECORD(GETWIDTH);
	return;
}
#endif /* Not linux */

/*
 * getws -- intercept getws
 */
wchar_t * getws(wchar_t *ws) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "getws");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *))actual)(ws);
	RECORD(GETWS);
	return rc;
}

/*
 * glob -- intercept glob
 */
int glob(const char *pattern,int flags,int (*errfunc)(const char *epath,int eerrno),glob_t *pglob) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "glob");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *,int,int(*)(const char *,int),glob_t *))actual)(pattern,flags,errfunc,pglob);
	RECORD(GLOB);
	return rc;
}


/*
 * globfree -- intercept globfree
 */
void globfree(glob_t *pglob) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "globfree");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(glob_t *))actual)(pglob);
	RECORD(GLOBFREE);
	return;
}

/*
 * gmtime -- intercept gmtime
 */
struct tm * gmtime(const time_t *clock) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct tm *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gmtime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct tm * (*)(const time_t *))actual)(clock);
	RECORD(GMTIME);
	return rc;
}

/*
 * grantpt -- intercept grantpt
 */
int grantpt(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "grantpt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(GRANTPT);
	return rc;
}

/*
 * gsignal -- intercept gsignal
 */
int gsignal(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "gsignal");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(sig);
	RECORD(GSIGNAL);
	return rc;
}

/*
 * hasmntopt -- intercept hasmntopt
 */
#if !defined(__linux)
char * hasmntopt(struct mnttab *mnt,char *opt) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "hasmntopt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(struct mnttab *, char *))actual)(mnt,opt);
	RECORD(HASMNTOPT);
	return rc;
}
#endif /* Not linux.*/


/*
 * hcreate -- intercept hcreate
 */
int hcreate(size_t mekments) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "hcreate");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(size_t ))actual)(mekments);
	RECORD(HCREATE);
	return rc;
}

/*
 * hdestroy -- intercept hdestroy
 */
void hdestroy(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "hdestroy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(HDESTROY);
	return;
}

/*
 * hsearch -- intercept hsearch
 */
ENTRY * hsearch(ENTRY item,ACTION action) {
	static void *actual = NULL;
	DECLARE_TIME;
	ENTRY *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "hsearch");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ENTRY * (*)(ENTRY, ACTION))actual)(item, action);
	RECORD(HSEARCH);
	return rc;
}

/*
 * iconv -- intercept iconv
 */
#undef CAST
#if defined(__sun)
size_t iconv(iconv_t cd,const char **inbuf,size_t *inbytesleft,char **outbuf,size_t *outbytesleft) {
#define CAST (size_t (*)(iconv_t,const char **, size_t *, char **, size_t *))
#elif defined(__linux)
size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft,
	      char **outbuf, size_t *outbytesleft) {
#define CAST (size_t (*)(iconv_t,char **, size_t *, char **, size_t *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "iconv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(cd,inbuf,inbytesleft,outbuf,outbytesleft);
	RECORD(ICONV);
	return rc;
}

/*
 * index -- intercept index
 */
char * index(const char *s,int c) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "index");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *s, int ))actual)(s, c);
	RECORD(INDEX);
	return rc;
}

/*
 * initgroups -- intercept initgroups
 */
int initgroups(const char *name,gid_t basegid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "initgroups");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, gid_t ))actual)(name,basegid);
	RECORD(INITGROUPS);
	return rc;
}

/*
 * initstate -- intercept initstate
 */
char * initstate(unsigned int seed,char *state,size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "initstate");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(unsigned int, char *, size_t))actual)(seed,state,size);
	RECORD(INITSTATE);
	return rc;
}

/*
 * innetgr -- intercept innetgr
 */
int innetgr(const char *netgroup,const char *machine,const char *user,const char *domain) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "innetgr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *, const char *, const char *))actual)(netgroup,machine,user,domain);
	RECORD(INNETGR);
	return rc;
}

/*
 * insque -- intercept insque
 */
void insque(void *elem,void *pred) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "insque");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void *, void *))actual)(elem,pred);
	RECORD(INSQUE);
	return;
}

/*
 * ioctl -- intercept ioctl
 */
#undef CAST
#if defined(__sun)
int ioctl(int fildes,int request,/* arg */ ...) {
#define CAST (int (*)(int, int, void *))
#elif defined(__linux)
int ioctl (int fildes, unsigned long int request, ...) {
#define CAST (int (*)(int, unsigned long, void *))
#endif
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, request);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ioctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(fildes, request, va_arg(ap, void *));
	RECORD(IOCTL);
	va_end(ap);
	return rc;
}



/*
 * isaexec -- intercept isaexec
 */
int isaexec(const char *path,char *const *argv,char *const *envp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "isaexec");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, char * const *, char * const *))actual)(path,argv,envp);
	RECORD(ISAEXEC);
	return rc;
}


/*
 * isalnum -- don;t intercept isalnum, it's probably a define
 * isalpha -- ditto
 * isascii -- ditto
 */

/*
 * isastream -- intercept isastream -- might be a define
 */
int isastream(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "isastream");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(ISASTREAM);
	return rc;
}

/*
 * isatty -- intercept isatty -- may be a define
 */
int isatty(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "isatty");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(ISATTY);
	return rc;
}

/*
 * iscntrl -- dont intercept iscntrl, it's a define
 * isdigit -- 
 * isgraph -- 
 * islower -- 
 */

/*
 * isnan -- intercept isnan
 */
int isnan(double dsrc) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "isnan");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(double ))actual)(dsrc);
	RECORD(ISNAN);
	return rc;
}

/*
 * isnand -- intercept isnand
 */
int isnand(double dsrc) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "isnand");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(double ))actual)(dsrc);
	RECORD(ISNAND);
	return rc;
}

/*
 * isnanf -- intercept isnanf
 */
int isnanf(float fsrc) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "isnanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(float ))actual)(fsrc);
	RECORD(ISNANF);
	return rc;
}

/*
 * isprint -- don't intercept isprint either
 * ispunct -- 
 */

/*
 * issetugid -- intercept issetugid
 */
int issetugid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "issetugid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(ISSETUGID);
	return rc;
}

/*
 * isspace -- don't intercept isspace
 * isupper -- 
 * iswalpha --
 * iswctype --
 * isxdigit --
 */

/*
 * jrand48 -- intercept jrand48
 */
long jrand48(unsigned short *xi ) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "jrand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(unsigned short *))actual)(xi);
	RECORD(JRAND48);
	return rc;
}


/*
 * kill -- intercept kill
 */
int kill(pid_t pid,int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "kill");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(pid_t, int ))actual)(pid, sig);
	RECORD(KILL);
	return rc;
}

/*
 * killpg -- intercept killpg
 */
int killpg(pid_t pgrp,int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "killpg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(pid_t, int ))actual)(pgrp, sig);
	RECORD(KILLPG);
	return rc;
}

/*
 * l64a -- intercept l64a
 */
char * l64a(long l) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "l64a");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(long))actual)(l);
	RECORD(L64A);
	return rc;
}

/*
 * labs -- intercept labs
 */
long labs(long lval) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "labs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(long ))actual)(lval);
	RECORD(LABS);
	return rc;
}

/*
 * lchown -- intercept lchown
 */
int lchown(const char *path,uid_t owner,gid_t group) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lchown");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, uid_t, gid_t ))actual)(path,owner,group);
	RECORD(LCHOWN);
	return rc;
}

/*
 * lckpwdf -- intercept lckpwdf
 */
int lckpwdf(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lckpwdf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(LCKPWDF);
	return rc;
}


/*
 * lcong48 -- intercept lcong48
 */
void lcong48(unsigned short *param) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lcong48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(unsigned short *))actual)(param);
	RECORD(LCONG48);
	return;
}


/*
 * ldexp -- intercept ldexp
 */
double ldexp(double x,int exp) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ldexp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(double, int ))actual)(x, exp);
	RECORD(LDEXP);
	return rc;
}


/*
 * ldiv -- intercept ldiv
 */
ldiv_t ldiv(long int numer,long int denom) {
	static void *actual = NULL;
	DECLARE_TIME;
	ldiv_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ldiv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ldiv_t (*)(long int,long int))actual)(numer,denom);
	RECORD(LDIV);
	return rc;
}

/*
 * lfind -- intercept lfind
 */
void * lfind(const void *key,const void *base,size_t *nelp,size_t width,int (*compar)(const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lfind");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *,const void *,size_t *,size_t ,int (*)(const void *,const void *)))actual)(key,base,nelp,width,compar);
	RECORD(LFIND);
	return rc;
}




/*
 * lfmt -- intercept lfmt, call underlying vlfmt
 */
int lfmt(FILE *stream,long flags,char *format,... /* arg*/) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vlfmt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, long, char *, va_list))actual)(stream,flags,format,ap);
	RECORD(LFMT);
	va_end(ap);
	return rc;
}


/*
 * link -- intercept link
 */
int link(const char *existing,const char *new) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "link");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *))actual)(existing,new);
	RECORD(LINK);
	return rc;
}

/*
 * llabs -- intercept llabs
 */
long long llabs(long long llval) {
	static void *actual = NULL;
	DECLARE_TIME;
	long long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "llabs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long long (*)(long long))actual)(llval);
	RECORD(LLABS);
	return rc;
}

/*
 * lldiv -- intercept lldiv
 */
#if !defined(__linux)
lldiv_t lldiv(long long numer,long long denom) {
	static void *actual = NULL;
	DECLARE_TIME;
	lldiv_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lldiv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((lldiv_t (*)(long long,long long))actual)(numer,denom);
	RECORD(LLDIV);
	return rc;
}
#endif /* Not linux */

/*
 * llseek -- intercept llseek
 */
#if !defined(__linux)
offset_t llseek(int fildes,offset_t offset,int whence) {
	static void *actual = NULL;
	DECLARE_TIME;
	offset_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "llseek");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((offset_t (*)(int, offset_t, int ))actual)(fildes,offset, whence);
	RECORD(LLSEEK);
	return rc;
}
#endif /* Not linux */

/*
 * lltostr -- intercept lltostr
 */
char * lltostr(long long value,char *endptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lltostr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(long long, char *))actual)(value,endptr);
	RECORD(LLTOSTR);
	return rc;
}

/*
 * localeconv -- intercept localeconv
 */
struct lconv * localeconv(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct lconv *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "localeconv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct lconv * (*)(void))actual)();
	RECORD(LOCALECONV);
	return rc;
}

/*
 * localtime -- intercept localtime
 */
struct tm * localtime(const time_t *clock) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct tm *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "localtime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct tm * (*)(const time_t *))actual)(clock);
	RECORD(LOCALTIME);
	return rc;
}

/*
 * lockf -- intercept lockf
 */
int lockf(int fildes,int function,off_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lockf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, off_t ))actual)(fildes, function,size);
	RECORD(LOCKF);
	return rc;
}

/*
 * longjmp -- don''t intercept longjmp, it doesn't return
 */

/*
 * lrand48 -- intercept lrand48
 */
long lrand48(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lrand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(void))actual)();
	RECORD(LRAND48);
	return rc;
}


/*
 * lsearch -- intercept lsearch
 */
void * lsearch(const void *key,void *base,size_t *nelp,size_t width,int (*compar) (const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lsearch");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *,void *,size_t *,size_t ,int (*) (const void *,const void *)))actual)(key,base,nelp,width,compar);
	RECORD(LSEARCH);
	return rc;
}


/*
 * lseek -- intercept lseek
 */
off_t lseek(int fildes,off_t offset,int whence) {
	static void *actual = NULL;
	DECLARE_TIME;
	off_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lseek");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((off_t (*)(int, off_t, int ))actual)(fildes,offset, whence);
	RECORD(LSEEK);
	return rc;
}

/*
 * lstat -- intercept lstat
 */
int lstat(const char *path,struct stat *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "lstat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, struct stat *))actual)(path,buf);
	RECORD(LSTAT);
	return rc;
}

/*
 * madvise -- intercept madvise
 */
#undef CAST
#if defined(__sun)
int madvise(caddr_t addr,size_t len,int advice) {
#define CAST (int (*)(caddr_t, size_t, int ))
#elif defined(__linux)
int madvise(void * addr,size_t len,int advice) {
#define CAST (int (*)(void *, size_t, int ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "madvise");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len, advice);
	RECORD(MADVISE);
	return rc;
}

#ifdef MAKECONTEXT_OK
/*
 * makecontext -- intercept makecontext
 */
void makecontext(ucontext_t *ucp,void(*func)(),int argc,...) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "makecontext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(ucontext_t *,void(*)(),int ,...))actual)(ucp,func,argc,...);
	RECORD(MAKECONTEXT);
	return;
}
#endif


/*
 * malloc -- intercept malloc
 */
void * malloc(size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "malloc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(size_t))actual)(size);
	RECORD(MALLOC);
	return rc;
}


/*
 * mblen -- intercept mblen
 */
int mblen(const char *s,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mblen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *s, size_t ))actual)(s,n);
	RECORD(MBLEN);
	return rc;
}

/*
 * mbrlen -- intercept mbrlen
 */
size_t mbrlen(const char *s,size_t n,mbstate_t *ps) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mbrlen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const char *s, size_t, mbstate_t *))actual)(s,n,ps);
	RECORD(MBRLEN);
	return rc;
}

/*
 * mbrtowc -- intercept mbrtowc
 */
size_t mbrtowc(wchar_t *pwc,const char *s,size_t n,mbstate_t *ps) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mbrtowc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(wchar_t *, const char *s, size_t, mbstate_t *))actual)(pwc,s,n,ps);
	RECORD(MBRTOWC);
	return rc;
}

/*
 * mbsinit -- intercept mbsinit
 */
int mbsinit(const mbstate_t *ps) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mbsinit");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const mbstate_t *))actual)(ps);
	RECORD(MBSINIT);
	return rc;
}

/*
 * mbsrtowcs -- intercept mbsrtowcs
 */
size_t mbsrtowcs(wchar_t *dst,const char **src,size_t len,mbstate_t *ps) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mbsrtowcs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(wchar_t *, const char **, size_t, mbstate_t *))actual)(dst,src,len,ps);
	RECORD(MBSRTOWCS);
	return rc;
}

/*
 * mbstowcs -- intercept mbstowcs
 */
size_t mbstowcs(wchar_t *pwcs,const char *s,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mbstowcs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(wchar_t *, const char *s, size_t ))actual)(pwcs,s,n);
	RECORD(MBSTOWCS);
	return rc;
}

/*
 * mbtowc -- intercept mbtowc
 */
int mbtowc(wchar_t *pwc,const char *s,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mbtowc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wchar_t *, const char *s, size_t ))actual)(pwc,s,n);
	RECORD(MBTOWC);
	return rc;
}

/*
 * memalign -- intercept memalign
 */
void * memalign(size_t alignment,size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memalign");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(size_t, size_t))actual)(alignment,size);
	RECORD(MEMALIGN);
	return rc;
}

/*
 * memccpy -- intercept memccpy
 */
void * memccpy(void *s1,const void *s2,int c,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memccpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(void *, const void *, int, size_t ))actual)(s1,s2, c,n);
	RECORD(MEMCCPY);
	return rc;
}

/*
 * memchr -- intercept memchr
 */
void * memchr(const void *s,int c,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memchr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *s, int, size_t ))actual)(s, c,n);
	RECORD(MEMCHR);
	return rc;
}

/*
 * memcmp -- intercept memcmp
 */
int memcmp(const void *s1,const void *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memcmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const void *, const void *, size_t ))actual)(s1,s2,n);
	RECORD(MEMCMP);
	return rc;
}

/*
 * memcntl -- intercept memcntl
 */
int memcntl(caddr_t addr,size_t len,int cmd,caddr_t arg,int attr,int mask) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memcntl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(caddr_t, size_t, int, caddr_t, int, int ))actual)(addr,len, cmd,arg, attr, mask);
	RECORD(MEMCNTL);
	return rc;
}

/*
 * memcpy -- intercept memcpy
 */
void * memcpy(void *s1,const void *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memcpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(void *, const void *, size_t ))actual)(s1,s2,n);
	RECORD(MEMCPY);
	return rc;
}


/*
 * meminfo -- intercept meminfo
 */
#if !defined(__linux)
int meminfo(const uint64_t *inaddr,int addr_count,const uint_t *info_req,int info_count,uint64_t *outdata,uint_t *validity) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "meminfo");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const uint64_t *, int, const uint_t *, int, uint64_t *, uint_t *))actual)(inaddr, addr_count, info_req, info_count,outdata,validity);
	RECORD(MEMINFO);
	return rc;
}
#endif /* Not linux */

/*
 * memmove -- intercept memmove
 */
void * memmove(void *s1,const void *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memmove");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(void *, const void *, size_t ))actual)(s1,s2,n);
	RECORD(MEMMOVE);
	return rc;
}

/*
 * memset -- intercept memset
 */
void * memset(void *s,int c,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "memset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(void *, int, size_t ))actual)(s, c,n);
	RECORD(MEMSET);
	return rc;
}

/*
 * mincore -- intercept mincore
 */
#undef CAST
#if defined(__sun)
int mincore(caddr_t addr,size_t len,char *vec) {
#define CAST (int (*)(caddr_t, size_t, char *))
#elif defined(__linux)
int mincore(void *addr,size_t len,unsigned char *vec) {
#define CAST (int (*)(void *, size_t, unsigned char *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mincore");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len,vec);
	RECORD(MINCORE);
	return rc;
}

/*
 * mkdir -- intercept mkdir
 */
int mkdir(const char *path,mode_t mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mkdir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, mode_t))actual)(path,mode);
	RECORD(MKDIR);
	return rc;
}

/*
 * mkfifo -- intercept mkfifo
 */
int mkfifo(const char *path,mode_t mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mkfifo");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, mode_t))actual)(path,mode);
	RECORD(MKFIFO);
	return rc;
}

/*
 * mknod -- intercept mknod
 */
int mknod(const char *path,mode_t mode,dev_t dev) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mknod");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, mode_t, dev_t))actual)(path,mode,dev);
	RECORD(MKNOD);
	return rc;
}

/*
 * mkstemp -- intercept mkstemp
 */
int mkstemp(char *template) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mkstemp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *))actual)(template);
	RECORD(MKSTEMP);
	return rc;
}

/*
 * mktemp -- intercept mktemp
 */
char * mktemp(char *template) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mktemp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(template);
	RECORD(MKTEMP);
	return rc;
}

/*
 * mktime -- intercept mktime
 */
time_t mktime(struct tm *timeptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	time_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mktime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((time_t (*)(struct tm *))actual)(timeptr);
	RECORD(MKTIME);
	return rc;
}

/*
 * mlock -- intercept mlock
 */
#undef CAST
#if defined(__sun)
int mlock(caddr_t addr, size_t len) {
#define CAST (int (*)(caddr_t, size_t ))
#elif defined(__linux)
int mlock(const void *addr, size_t len) {
#define CAST (int (*)(const void *, size_t ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mlock");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len);
	RECORD(MLOCK);
	return rc;
}

/*
 * mlockall -- intercept mlockall
 */
int mlockall(int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mlockall");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(flags);
	RECORD(MLOCKALL);
	return rc;
}

/*
 * mmap -- intercept mmap
 */
#undef CAST
#if defined(__sun)
char * mmap(char *addr,size_t len,int prot,int flags,int fildes,off_t off) {
#define CAST (char *(*)(char *, size_t, int, int, int, off_t))
#elif defined(__linux)
void * mmap(void *addr,size_t len,int prot,int flags,int fildes,off_t off) {
#define CAST (char *(*)(void *, size_t, int, int, int, off_t))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mmap");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len, prot, flags, fildes,off);
	RECORD(MMAP);
	return rc;
}

/*
 * modf -- intercept modf
 */
double modf(double x,double *iptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "modf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(double, double *))actual)(x,iptr);
	RECORD(MODF);
	return rc;
}

/*
 * modff -- intercept modff
 */
float modff(float x,float *iptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	float	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "modff");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((float (*)(float, float *))actual)(x,iptr);
	RECORD(MODFF);
	return rc;
}

/*
 * monitor -- intercept monitor
 */
#if !defined(__linux)
void monitor(int (*lowpc)(),int (*highpc)(),WORD *buffer,size_t bufsize,size_t nfunc) { 
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "monitor");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(int (*)(),int (*)(),WORD *,size_t ,size_t))actual)(lowpc,highpc,buffer,bufsize,nfunc);
	RECORD(MONITOR);
	return;
}
#endif /* Not linux */

#ifdef MOUNT_OK 
/*
 * mount -- intercept mount, which has a wildly different prototype
 *	than the include file says.
 */
int mount(const char *spec,const char *dir,int mflag,char *fstype,char *dataptr,int datalen,char *optptr, int optlen) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mount");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *, int, char *, char *, int, char *, int ))actual)(spec,dir, mflag,fstype,dataptr, datalen,optptr, optlen);
	RECORD(MOUNT);
	return rc;
}
#endif /* MOUNT_OK */

/*
 * mprotect -- intercept mprotect
 */
#undef CAST
#if defined(__sun)
int mprotect(char *addr,size_t len,int prot) {
#define CAST (int (*)(char *, size_t, int ))
#elif defined(__linux)
int mprotect(void *addr,size_t len,int prot) {
#define CAST (int (*)(void *, size_t, int ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mprotect");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len, prot);
	RECORD(MPROTECT);
	return rc;
}

/*
 * mrand48 -- intercept mrand48
 */
long mrand48(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "mrand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(void))actual)();
	RECORD(MRAND48);
	return rc;
}

/*
 * msgctl -- intercept msgctl
 */
int msgctl(int msqid,int cmd,struct msqid_ds *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msgctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, struct msqid_ds *))actual)(msqid, cmd,buf);
	RECORD(MSGCTL);
	return rc;
}

/*
 * msgget -- intercept msgget
 */
int msgget(key_t key,int msgflg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msgget");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(key_t, int ))actual)(key, msgflg);
	RECORD(MSGGET);
	return rc;
}

/*
 * msgids -- intercept msgids
 */
#if !defined(__linux)
int msgids(int *buf,uint_t nids,uint_t *pnids) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msgids");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int *, uint_t, uint_t *))actual)(buf,nids,pnids);
	RECORD(MSGIDS);
	return rc;
}
#endif /* Not linux */


/*
 * msgrcv -- intercept msgrcv
 */
ssize_t msgrcv(int msqid,void *msgp,size_t msgsz,long int msgtyp,int msgflg) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msgrcv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, void *, size_t, long int, int ))actual)(msqid,msgp,msgsz, msgtyp, msgflg);
	RECORD(MSGRCV);
	return rc;
}

/*
 * msgsnap -- intercept msgsnap
 */
int msgsnap(int msqid,void *buf,size_t bufsz,long msgtyp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msgsnap");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, void *, size_t, long ))actual)(msqid,buf,bufsz,msgtyp);
	RECORD(MSGSNAP);
	return rc;
}

/*
 * msgsnd -- intercept msgsnd
 */
int msgsnd(int msqid,const void *msgp,size_t msgsz,int msgflg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msgsnd");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const void *, size_t, int ))actual)(msqid,msgp,msgsz, msgflg);
	RECORD(MSGSND);
	return rc;
}

/*
 * msync -- intercept msync
 */
#undef CAST
#if defined(__sun)
int msync(char *addr,size_t len,int flags) {
#define CAST (int (*)(char *, size_t, int ))
#elif defined(__linux)
int msync(void *addr,size_t len,int flags) {
#define CAST (int (*)(void *, size_t, int ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "msync");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len, flags);
	RECORD(MSYNC);
	return rc;
}

/*
 * munlock -- intercept munlock
 */
#undef CAST
#if defined(__sun)
int munlock(caddr_t addr,size_t len) {
#define CAST (int (*)(caddr_t, size_t ))
#elif defined(__linux)
int munlock(const void *addr,size_t len) {
#define CAST (int (*)(const void *, size_t ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "munlock");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len);
	RECORD(MUNLOCK);
	return rc;
}

/*
 * munlockall -- intercept munlockall
 */
int munlockall(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "munlockall");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(MUNLOCKALL);
	return rc;
}

/*
 * munmap -- intercept munmap
 */
#undef CAST
#if defined(__sun)
int munmap(char *addr,size_t len) {
#define CAST (int (*)(char *, size_t ))
#elif defined(__linux)
int munmap(void *addr,size_t len) {
#define CAST (int (*)(void *, size_t ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "munmap");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(addr,len);
	RECORD(MUNMAP);
	return rc;
}

#ifdef NFTW_OK
/*
 * nftw -- intercept nftw
 */
int nftw(const char *path, int (*fn)(const char *,const struct stat *,int,struct FTW *),int depth,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "nftw");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *,int (*)(const char *,const struct stat *,int,struct FTW *),int,int))actual)(path,fn,depth,flags);
	RECORD(NFTW);
	return rc;
}
#endif


/*
 * ngettext -- intercept ngettext
 */
char * ngettext(const char *msgid1,const char *msgid2,unsigned long int n) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ngettext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *, unsigned long int))actual)(msgid1,msgid2, n);
	RECORD(NGETTEXT);
	return rc;
}

/*
 * nice -- intercept nice
 */
int nice(int incr) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "nice");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(incr);
	RECORD(NICE);
	return rc;
}


/*
 * nrand48 -- intercept nrand48
 */
long nrand48(unsigned short *xi) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "nrand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(unsigned short *))actual)(xi);
	RECORD(NRAND48);
	return rc;
}

/*
 * open -- intercept open
 */
int open(const char *path, int oflag, ...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, oflag);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "open");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, int, mode_t))actual)(path, oflag, va_arg(ap,mode_t));
	RECORD(OPEN);
	va_end(ap);
	return rc;
}



/*
 * openat -- intercept openat
 */
int openat(int fildes,const char *path,int oflag, ...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, oflag);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "openat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, int, mode_t))actual)(fildes,path, oflag, va_arg(ap, mode_t));
	RECORD(OPENAT);
	return rc;
}


/*
 * opendir-- intercept opendir
 */
DIR * opendir(const char *dirname) {
	static void *actual = NULL;
	DECLARE_TIME;
	DIR *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "opendir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((DIR * (*)(const char *))actual)(dirname);
	RECORD(OPENDIR);
	return rc;
}

/*
 * openlog -- intercept openlog
 */
void openlog(const char *ident,int logopt,int facility) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "openlog");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const char *, int, int ))actual)(ident, logopt, facility);
	RECORD(OPENLOG);
	return;
}

/*
 * pathconf -- intercept pathconf
 */
long pathconf(const char *path, int name) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pathconf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(const char *, int ))actual)(path, name);
	RECORD(PATHCONF);
	return rc;
}

/*
 * pause -- intercept pause
 */
int pause(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pause");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(PAUSE);
	return rc;
}

/*
 * pclose -- intercept pclose
 */
int pclose(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pclose");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(stream);
	RECORD(PCLOSE);
	return rc;
}


/*
 * pcsample -- intercept pcsample
 */
long pcsample(uintptr_t *samples, long nsamples) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pcsample");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(uintptr_t *, long))actual)(samples,nsamples);
	RECORD(PCSAMPLE);
	return rc;
}


/*
 * perror -- intercept perror
 */
void perror(const char *s) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "perror");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const char *s))actual)(s);
	RECORD(PERROR);
	return;
}


/*
 * pfmt -- intercept pfmt, call underlying vpfmt
 */
int pfmt(FILE *stream,long flags,char *format,... /* arg */) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vpfmt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, long, char *, va_list))actual)(stream,flags,format,ap);
	RECORD(PFMT);
	va_end(ap);
	return rc;
}




/*
 * pipe -- intercept pipe
 */
int pipe(int *fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pipe");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int *))actual)(fildes);
	RECORD(PIPE);
	return rc;
}


/*
 * plock -- intercept plock
 */
int plock(int op) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "plock");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(op);
	RECORD(PLOCK);
	return rc;
}


/*
 * poll -- intercept poll
 */
int poll(struct pollfd *fds,nfds_t nfds,int timeout) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "poll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(struct pollfd *, nfds_t, int ))actual)(fds,nfds, timeout);
	RECORD(POLL);
	return rc;
}

/*
 * popen -- intercept popen
 */
FILE * popen(const char *command,const char *mode) {
	static void *actual = NULL;
	DECLARE_TIME;
	FILE *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "popen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((FILE * (*)(const char *, const char *))actual)(command,mode);
	RECORD(POPEN);
	return rc;
}

/*
 * pread -- intercept pread
 */
ssize_t pread(int fildes,void *buf,size_t nbyte,off_t offset) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pread");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, void *, size_t, off_t ))actual)(fildes,buf,nbyte,offset);
	RECORD(PREAD);
	return rc;
}


/*
 * printf -- intercept printf, call underlying vprintf
 */
int printf(const char *format,/* args*/ ...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, va_list))actual)(format, ap);
	RECORD(PRINTF);
	va_end(ap);
	return rc;
}


/*
 * printstack -- intercept printstack
 */
int printstack(int fd) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "printstack");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fd);
	RECORD(PRINTSTACK);
	return rc;
}

/*
 * priocntl -- intercept priocntl
 */
long priocntl(idtype_t idtype,id_t id,int cmd,/* arg */ ...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	va_start(ap, cmd);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "priocntl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(idtype_t, id_t, int, void *))actual)(idtype,id, cmd, va_arg(ap, void *));
	RECORD(PRIOCNTL);
	va_end(ap);
	return rc;
}


/*
 * priocntlset -- intercept priocntlset
 */
#if defined(__sun)
long priocntlset(procset_t *psp,int cmd,/* arg */ ...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	va_start(ap, cmd);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "priocntlset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(procset_t *, int, void *))actual)(psp, cmd, va_arg(ap, void *));
	RECORD(PRIOCNTLSET);
	va_end(ap);
	return rc;
}
#endif

/*
 * profil -- don't intercept profil, that biases it.
 */

/*
 * psiginfo -- intercept psiginfo
 */
void psiginfo(siginfo_t *pinfo,char *s) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "psiginfo");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(siginfo_t *, char *))actual)(pinfo,s);
	RECORD(PSIGINFO);
	return;
}

/*
 * psignal -- intercept psignal
 */
void psignal(int sig,const char *s) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "psignal");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(int, const char *s))actual)(sig,s);
	RECORD(PSIGNAL);
	return;
}

/*
 * ptrace -- intercept ptrace
 */
long ptrace(int request,pid_t pid,long addr,long data) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ptrace");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(int, pid_t, long, long ))actual)(request,pid, addr, data);
	RECORD(PTRACE);
	return rc;
}

/*
 * ptsname -- intercept ptsname
 */
char * ptsname(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ptsname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(int ))actual)(fildes);
	RECORD(PTSNAME);
	return rc;
}

/*
 * putacct -- intercept putacct
 */
int putacct(idtype_t idtype,id_t id,void *buf,size_t bufsize,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putacct");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(idtype_t, id_t, void *, size_t, int ))actual)(idtype,id,buf,bufsize, flags);
	RECORD(PUTACCT);
	return rc;
}

/*
 * putc -- don't intercept putc, it can be a define
 * putchar -- don't intercept putchar, ditto
 */


/*
 * putenv -- intercept putenv
 */
int putenv(char *string) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putenv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *))actual)(string);
	RECORD(PUTENV);
	return rc;
}

/*
 * putmsg -- intercept putmsg
 */
int putmsg(int fildes,const struct strbuf *ctlptr,const struct strbuf *dataptr,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putmsg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const struct strbuf *, const struct strbuf *, int ))actual)(fildes,ctlptr,dataptr, flags);
	RECORD(PUTMSG);
	return rc;
}

/*
 * putpmsg -- intercept putpmsg
 */
int putpmsg(int fildes,const struct strbuf *ctlptr,const struct strbuf *dataptr,int band,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putpmsg");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const struct strbuf *, const struct strbuf *, int, int ))actual)(fildes,ctlptr,dataptr, band, flags);
	RECORD(PUTPMSG);
	return rc;
}

/*
 * putpwent -- intercept putpwent
 */
int putpwent(const struct passwd *p,FILE *f) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putpwent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const struct passwd *, FILE *))actual)(p,f);
	RECORD(PUTPWENT);
	return rc;
}

/*
 * puts -- intercept puts
 */
int puts(const char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "puts");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *s))actual)(s);
	RECORD(PUTS);
	return rc;
}

/*
 * putspent -- intercept putspent
 */
int putspent(const struct spwd *p,FILE *fp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putspent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const struct spwd *, FILE *))actual)(p,fp);
	RECORD(PUTSPENT);
	return rc;
}

/*
 * pututline -- intercept pututline
 */
struct utmp * pututline(const struct utmp *utmp) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmp *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pututline");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmp * (*)(const struct utmp *))actual)(utmp);
	RECORD(PUTUTLINE);
	return rc;
}

/*
 * pututxline -- intercept pututxline
 */
struct utmpx * pututxline(const struct utmpx *utmpx) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct utmpx *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pututxline");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct utmpx * (*)(const struct utmpx *))actual)(utmpx);
	RECORD(PUTUTXLINE);
	return rc;
}

/*
 * putw -- intercept putw
 */
int putw(int w,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putw");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, FILE *))actual)(w,stream);
	RECORD(PUTW);
	return rc;
}

/*
 * putwc -- intercept putwc
 */
wint_t putwc(wchar_t wc,FILE*stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t 	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putwc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wchar_t, FILE*))actual)(wc,stream);
	RECORD(PUTWC);
	return rc;
}

/*
 * putwchar -- intercept putwchar
 */
wint_t putwchar(wchar_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putwchar");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wchar_t))actual)(wc);
	RECORD(PUTWCHAR);
	return rc;
}

/*
 * putws -- intercept putws
 */
int putws(const wchar_t *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "putws");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *))actual)(s);
	RECORD(PUTWS);
	return rc;
}

/*
 * pwrite -- intercept pwrite
 */
ssize_t pwrite(int fildes,const void *buf,size_t nbyte,off_t offset) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "pwrite");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, const void *, size_t, off_t ))actual)(fildes,buf,nbyte,offset);
	RECORD(PWRITE);
	return rc;
}

/*
 * qeconvert -- intercept qeconvert
 */
#if defined(__sun)
char * qeconvert(quadruple *value,int ndigit,int *decpt,int *sign,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "qeconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(quadruple *, int, int *, int *, char *))actual)(value, ndigit,decpt,sign,buf);
	RECORD(QECONVERT);
	return rc;
}
#endif

/*
 * qfconvert -- intercept qfconvert
 */
#if defined(__sun)
char * qfconvert(quadruple *value,int ndigit,int *decpt,int *sign,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "qfconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(quadruple *, int, int *, int *, char *))actual)(value, ndigit,decpt,sign,buf);
	RECORD(QFCONVERT);
	return rc;
}
#endif

/*
 * qgconvert -- intercept qgconvert
 */
#if defined(__sun)
char * qgconvert(quadruple *value,int ndigit,int trailing,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "qgconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(quadruple *, int, int, char *))actual)(value, ndigit, trailing,buf);
	RECORD(QGCONVERT);
	return rc;
}
#endif

/*
 * qsort -- intercept qsort
 */
void qsort(void *base,size_t nel,size_t width,int (*compar)(const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "qsort");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void *,size_t ,size_t,int (*)(const void *,const void *)))actual)(base,nel,width,*compar);
	RECORD(QSORT);
	return;
}


/*
 * raise -- intercept raise
 */
int raise(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "raise");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(sig);
	RECORD(RAISE);
	return rc;
}

/*
 * rand -- intercept rand
 */
int rand(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "rand");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(RAND);
	return rc;
}

/*
 * random -- intercept random
 */
long random(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "random");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(void))actual)();
	RECORD(RANDOM);
	return rc;
}

/*
 * read -- intercept read
 */
ssize_t read(int fildes,void *buf,size_t nbyte) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "read");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, void *, size_t ))actual)(fildes,buf,nbyte);
	RECORD(READ);
	return rc;
}

/*
 * readdir -- intercept readdir
 */
struct dirent * readdir(DIR *dirp) {
	static void *actual = NULL;
	DECLARE_TIME;
	struct dirent *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "readdir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((struct dirent * (*)(DIR *))actual)(dirp);
	RECORD(READDIR);
	return rc;
}

/*
 * readlink -- intercept readlink
 */
int readlink(const char *path,char *buf,size_t bufsiz) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "readlink");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, char *, size_t ))actual)(path,buf,bufsiz);
	RECORD(READLINK);
	return rc;
}

/*
 * readv -- intercept readv
 */
ssize_t readv(int fildes,const struct iovec *iov,int iovcnt) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "readv");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, const struct iovec *, int ))actual)(fildes,iov, iovcnt);
	RECORD(READV);
	return rc;
}

/*
 * realloc -- intercept realloc
 */
void * realloc(void *ptr,size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "realloc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(void *, size_t))actual)(ptr,size);
	RECORD(REALLOC);
	return rc;
}

/*
 * realpath -- intercept realpath
 */
char * realpath(const char *file_name,char *resolved_name) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "realpath");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, char *))actual)(file_name,resolved_name);
	RECORD(REALPATH);
	return rc;
}

/*
 * reboot -- intercept reboot
 */
int reboot(int howto,char *bootargs) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "reboot");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, char *))actual)(howto,bootargs);
	RECORD(REBOOT);
	return rc;
}

#ifdef REGCMP_OK
/*
 * regcmp -- intercept regcmp, proabably requiring assembler.
 */
char * regcmp(const char *string1,/* char *string2 */ ...,int /*(char*)0*/) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "regcmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, /* char *string2 */ ..., int /*(char*)0*/))actual)(string1,/ char string2 / , /(char)0/);
	RECORD(REGCMP);
	return rc;
}
#endif /* REGCMP_OK */


/*
 * regcomp -- intercept regcomp
 */
int regcomp(regex_t *preg,const char *pattern,int cflags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "regcomp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(regex_t *, const char *, int ))actual)(preg,pattern, cflags);
	RECORD(REGCOMP);
	return rc;
}

/*
 * regerror -- intercept regerror
 */
size_t regerror(int errcode,const regex_t *preg,char *errbuf,size_t errbuf_size) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "regerror");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(int, const regex_t *, char *, size_t ))actual)(errcode,preg,errbuf,errbuf_size);
	RECORD(REGERROR);
	return rc;
}

#ifdef REGEX_OK
/*
 * regex -- intercept regex
 */
char * regex(const char *re,const char *subject,/* char *ret0 */ ...) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "regex");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *, /* char *ret0 */ ...))actual)(re,subject,/ char ret0 / );
	RECORD(REGEX);
	return rc;
}
#endif /* REGEX_OK */

/*
 * regexec -- intercept regexec
 */
int regexec(const regex_t *preg,const char *string,size_t nmatch,regmatch_t *pmatch,int eflags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "regexec");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const regex_t *, const char *, size_t, regmatch_t *, int ))actual)(preg,string,nmatch,pmatch, eflags);
	RECORD(REGEXEC);
	return rc;
}


/*
 * regfree -- intercept regfree
 */
void regfree(regex_t *preg) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "regfree");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(regex_t *))actual)(preg);
	RECORD(REGFREE);
	return;
}

/*
 * remove -- intercept remove
 */
int remove(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "remove");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(REMOVE);
	return rc;
}

/*
 * remque -- intercept remque
 */
void remque(void *elem) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "remque");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void *))actual)(elem);
	RECORD(REMQUE);
	return;
}

/*
 * rename -- intercept rename
 */
int rename(const char *old,const char *new) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "rename");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *))actual)(old,new);
	RECORD(RENAME);
	return rc;
}

/*
 * renameat -- intercept renameat
 */
int renameat(int fromfd,const char *old,int tofd,const char *new) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "renameat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, int, const char *))actual)(fromfd,old, tofd,new);
	RECORD(RENAMEAT);
	return rc;
}

/*
 * resetmnttab -- intercept resetmnttab
 */
void resetmnttab(FILE *fp) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "resetmnttab");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(FILE *))actual)(fp);
	RECORD(RESETMNTTAB);
	return;
}

/*
 * resolvepath -- intercept resolvepath
 */
int resolvepath(const char *path,char *buf,size_t bufsiz) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "resolvepath");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, char *, size_t ))actual)(path,buf,bufsiz);
	RECORD(RESOLVEPATH);
	return rc;
}

/*
 * rewind -- intercept rewind
 */
void rewind(FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "rewind");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(FILE *))actual)(stream);
	RECORD(REWIND);
	return;
}

/*
 * rewinddir -- don't intercept rewinddir,. it can be a define.
 */


/*
 * rindex -- intercept rindex
 */
char * rindex(const char *s,int c) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "rindex");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *s, int ))actual)(s, c);
	RECORD(RINDEX);
	return rc;
}

/*
 * rmdir -- intercept rmdir
 */
int rmdir(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "rmdir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(RMDIR);
	return rc;
}

/*
 * sbrk -- intercept sbrk
 */
void * sbrk(intptr_t incr) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sbrk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(intptr_t ))actual)(incr);
	RECORD(SBRK);
	return rc;
}

/*
 * scanf -- intercept scanf, call underlying vscanf
 */
int scanf(const char *format,...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, va_list))actual)(format,ap);
	RECORD(SCANF);
	va_end(ap);
	return rc;
}


/*
 * seconvert -- intercept seconvert
 */
#if defined(__sun)
char * seconvert(single *value,int ndigit,int *decpt,int *sign,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "seconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(single *, int, int *, int *, char *))actual)(value, ndigit,decpt,sign,buf);
	RECORD(SECONVERT);
	return rc;
}
#endif

/*
 * seed48 -- intercept seed48
 */
unsigned short * seed48(unsigned short *seed16v) {
	static void *actual = NULL;
	DECLARE_TIME;
	unsigned short *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "seed48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((unsigned short * (*)(unsigned short *))actual)(seed16v);
	RECORD(SEED48);
	return rc;
}


/*
 * seekdir -- intercept seekdir
 */
void seekdir(DIR *dirp,long int loc) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "seekdir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(DIR *, long int ))actual)(dirp, loc);
	RECORD(SEEKDIR);
	return;
}

/*
 * select -- intercept select
 */
int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "select");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, fd_set *, fd_set *, fd_set *, struct timeval *))actual)(nfds,readfds,writefds,errorfds,timeout);
	RECORD(SELECT);
	return rc;
}


/*
 * semctl -- intercept semctl
 */
int semctl(int semid,int semnum,int cmd,...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, cmd);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "semctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, int, void *))actual)(semid, semnum, cmd, va_arg(ap, void *));
	RECORD(SEMCTL);
	va_end(ap);
	return rc;
}


/*
 * semget -- intercept semget
 */
int semget(key_t key,int nsems,int semflg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "semget");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(key_t, int, int ))actual)(key, nsems, semflg);
	RECORD(SEMGET);
	return rc;
}

/*
 * semids -- intercept semids
 */
#if defined(__sun)
int semids(int *buf,uint_t nids,uint_t *pnids) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "semids");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int *, uint_t, uint_t *))actual)(buf,nids,pnids);
	RECORD(SEMIDS);
	return rc;
}
#endif

/*
 * semop -- intercept semop
 */
int semop(int semid,struct sembuf *sops,size_t nsops) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "semop");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct sembuf *, size_t ))actual)(semid,sops,nsops);
	RECORD(SEMOP);
	return rc;
}

/*
 * semtimedop -- intercept semtimedop
 */
int semtimedop(int semid,struct sembuf *sops,size_t nsops,const struct timespec *timeout) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "semtimedop");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct sembuf *, size_t, const struct timespec *))actual)(semid,sops,nsops,timeout);
	RECORD(SEMTIMEDOP);
	return rc;
}

/*
 * setbuf -- intercept setbuf
 */
void setbuf(FILE *stream,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setbuf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(FILE *, char *))actual)(stream,buf);
	RECORD(SETBUF);
	return;
}

/*
 * setbuffer -- intercept setbuffer
 */
void setbuffer(FILE *iop,char *abuf,size_t asize) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setbuffer");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(FILE *, char *, size_t ))actual)(iop,abuf,asize);
	RECORD(SETBUFFER);
	return;
}

/*
 * setcat -- intercept setcat
 */
char * setcat(const char *catalog) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setcat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(catalog);
	RECORD(SETCAT);
	return rc;
}

/*
 * setcontext -- intercept setcontext
 */
int setcontext(const ucontext_t *ucp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setcontext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const ucontext_t *))actual)(ucp);
	RECORD(SETCONTEXT_);
	return rc;
}

/*
 * setegid -- intercept setegid
 */
int setegid(gid_t egid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setegid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(gid_t ))actual)(egid);
	RECORD(SETEGID);
	return rc;
}

/*
 * seteuid -- intercept seteuid
 */
int seteuid(uid_t euid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "seteuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(uid_t ))actual)(euid);
	RECORD(SETEUID);
	return rc;
}

/*
 * setgid -- intercept setgid
 */
int setgid(gid_t gid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setgid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(gid_t))actual)(gid);
	RECORD(SETGID);
	return rc;
}

/*
 * setgrent -- intercept setgrent
 */
void setgrent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(SETGRENT);
	return;
}

/*
 * setgroups -- intercept setgroups
 */
int setgroups(int ngroups,const gid_t *grouplist) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setgroups");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const gid_t *))actual)(ngroups,grouplist);
	RECORD(SETGROUPS);
	return rc;
}

/*
 * sethostname -- intercept sethostname
 */
#undef CAST
#if defined(__sun)
int sethostname(char *name,int namelen) {
#define CAST (int (*)(char *, int ))
#elif defined(__linux)
int sethostname(const char *name,size_t namelen) {
#define CAST (int (*)(const char *, int ))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sethostname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(name, namelen);
	RECORD(SETHOSTNAME);
	return rc;
}

/*
 * setitimer -- intercept setitimer
 */
#undef CAST
#if defined(__sun)
int setitimer(int which, struct itimerval *value,struct itimerval *ovalue) {
#define CAST (int (*)(int, struct itimerval *, struct itimerval *))
#endif
#if defined(__linux)
int setitimer(int which, const struct itimerval *value,struct itimerval *ovalue) {
#define CAST (int (*)(int, const struct itimerval *, struct itimerval *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setitimer");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(which,value,ovalue);
	RECORD(SETITIMER);
	return rc;
}

/*
 * setjmp -- intercept setjmp
 */
int setjmp(jmp_buf env) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setjmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(jmp_buf))actual)(env);
	RECORD(SETJMP);
	return rc;
}

/*
 * setkey -- intercept setkey
 */
void setkey(const char *key) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setkey");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const char *))actual)(key);
	RECORD(SETKEY);
	return;
}

/*
 * setlabel -- intercept setlabel
 */
int setlabel(const char *label) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setlabel");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(label);
	RECORD(SETLABEL);
	return rc;
}

/*
 * setlinebuf -- intercept setlinebuf
 */
#if defined(__sun) /* Linux function is returns void. */
int setlinebuf(FILE *iop) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setlinebuf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *))actual)(iop);
	RECORD(SETLINEBUF);
	return rc;
}
#endif

/*
 * setlocale -- intercept setlocale
 */
char * setlocale(int category,const char *locale) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setlocale");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(int, const char *))actual)(category,locale);
	RECORD(SETLOCALE);
	return rc;
}

/*
 * setlogmask -- intercept setlogmask
 */
int setlogmask(int maskpri) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setlogmask");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(maskpri);
	RECORD(SETLOGMASK);
	return rc;
}

/*
 * setnetgrent -- intercept setnetgrent
 */
int setnetgrent(const char *netgroup) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setnetgrent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(netgroup);
	RECORD(SETNETGRENT);
	return rc;
}

/*
 * setpgid -- intercept setpgid
 */
int setpgid(pid_t pid,pid_t pgid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setpgid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(pid_t, pid_t ))actual)(pid,pgid);
	RECORD(SETPGID);
	return rc;
}

/*
 * setpgrp -- intercept setpgrp
 */
pid_t setpgrp(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setpgrp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(SETPGRP);
	return rc;
}

/*
 * setpriority -- intercept setpriority
 */
int setpriority(int which,id_t who,int priority) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setpriority");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, id_t, int ))actual)(which,who, priority);
	RECORD(SETPRIORITY);
	return rc;
}

/*
 * setpwent -- intercept setpwent
 */
void setpwent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setpwent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(SETPWENT);
	return;
}

/*
 * setrctl -- intercept setrctl
 */
#if defined(__sun)
int setrctl(const char *controlname,rctlblk_t *old_blk,rctlblk_t *new_blk, int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setrctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, rctlblk_t *, rctlblk_t *, int ))actual)(controlname,old_blk,new_blk,flags);
	RECORD(SETRCTL);
	return rc;
}
#endif 
/*
 * setregid -- intercept setregid
 */
int setregid(gid_t rgid,gid_t egid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setregid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(gid_t, gid_t ))actual)(rgid,egid);
	RECORD(SETREGID);
	return rc;
}

/*
 * setreuid -- intercept setreuid
 */
int setreuid(uid_t ruid,uid_t euid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setreuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(uid_t, uid_t ))actual)(ruid,euid);
	RECORD(SETREUID);
	return rc;
}

/*
 * setrlimit -- intercept setrlimit
 */
int setrlimit(int resource,const struct rlimit *rlp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setrlimit");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const struct rlimit *))actual)(resource,rlp);
	RECORD(SETRLIMIT);
	return rc;
}

/*
 * setsid -- intercept setsid
 */
pid_t setsid(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setsid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(SETSID);
	return rc;
}

/*
 * setspent -- intercept setspent
 */
void setspent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setspent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(SETSPENT);
	return;
}

/*
 * setstate -- intercept setstate
 */
#undef CAST
#if defined(__sun)
char * setstate(const char *state) {
#define CAST (char * (*)(const char *))
#elif defined(__linux)
char * setstate(char *state) {
#define CAST (char * (*)(char *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setstate");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(state);
	RECORD(SETSTATE);
	return rc;
}

/*
 * settaskid -- intercept settaskid
 */
#if defined(__sun)
taskid_t settaskid(projid_t project, uint_t flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	taskid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "settaskid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((taskid_t (*)(projid_t, uint_t))actual)(project, flags);
	RECORD(SETTASKID);
	return rc;
}
#endif

/*
 * settimeofday -- intercept settimeofday
 */
#undef CAST
#if defined(__sun)
int settimeofday(struct timeval *tp,void *tz) {
#define CAST (int (*)(struct timeval *, void *))
#elif defined(__linux)
int settimeofday(const struct timeval *tp,const struct timezone *tz) {
#define CAST (int (*)(const struct timeval *, const struct timezone *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "settimeofday");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(tp,tz);
	RECORD(SETTIMEOFDAY);
	return rc;
}

/*
 * setuid -- intercept setuid
 */
int setuid(uid_t uid) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setuid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(uid_t))actual)(uid);
	RECORD(SETUID);
	return rc;
}

/*
 * setustack -- intercept setustack
 */
int setustack(stack_t *sp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setustack");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(stack_t *))actual)(sp);
	RECORD(SETUSTACK_);
	return rc;
}

/*
 * setutent -- intercept setutent
 */
void setutent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setutent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(SETUTENT);
	return;
}

/*
 * setutxent -- intercept setutxent
 */
void setutxent(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setutxent");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(SETUTXENT);
	return;
}

/*
 * setvbuf -- intercept setvbuf
 */
int setvbuf(FILE *stream,char *buf,int type,size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "setvbuf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, char *, int, size_t))actual)(stream,buf, type,size);
	RECORD(SETVBUF);
	return rc;
}

/*
 * sfconvert -- intercept sfconvert
 */
#if !defined(__linux)
char * sfconvert(single *value,int ndigit,int *decpt,int *sign,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sfconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(single *, int, int *, int *, char *))actual)(value, ndigit,decpt,sign,buf);
	RECORD(SFCONVERT);
	return rc;
}
#endif 

/*
 * sgconvert -- intercept sgconvert
 */
#if !defined(__linux)
char * sgconvert(single *value,int ndigit,int trailing,char *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sgconvert");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(single *, int, int, char *))actual)(value, ndigit, trailing,buf);
	RECORD(SGCONVERT);
	return rc;
}
#endif

/*
 * shmat -- intercept shmat
 */
void * shmat(int shmid,const void *shmaddr,int shmflg) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "shmat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(int, const void *, int ))actual)(shmid,shmaddr, shmflg);
	RECORD(SHMAT);
	return rc;
}

/*
 * shmctl -- intercept shmctl
 */
int shmctl(int shmid,int cmd,struct shmid_ds *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "shmctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, struct shmid_ds *))actual)(shmid, cmd,buf);
	RECORD(SHMCTL);
	return rc;
}

/*
 * shmdt -- intercept shmdt
 */
#undef CAST
#if defined(__sun)
int shmdt(char *shmaddr) {
#define CAST (int (*)(char *))
#elif defined(__linux)
int shmdt(const void *shmaddr) {
#define CAST (int (*)(const void *))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "shmdt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = (CAST actual)(shmaddr);
	RECORD(SHMDT);
	return rc;
}

/*
 * shmget -- intercept shmget
 */
int shmget(key_t key,size_t size,int shmflg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "shmget");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(key_t, size_t, int ))actual)(key,size, shmflg);
	RECORD(SHMGET);
	return rc;
}

/*
 * shmids -- intercept shmids
 */
#if !defined(__linux)
int shmids(int *buf,uint_t nids,uint_t *pnids) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "shmids");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int *, uint_t, uint_t *))actual)(buf,nids,pnids);
	RECORD(SHMIDS);
	return rc;
}
#endif
/*
 * sig2str -- intercept sig2str
 */
int sig2str(int signum,char *str) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sig2str");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, char *))actual)(signum,str);
	RECORD(SIG2STR);
	return rc;
}

/*
 * sigaction -- intercept sigaction
 */
int sigaction(int sig,const struct sigaction *act,struct sigaction *oact) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigaction");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const struct sigaction *, struct sigaction *))actual)(sig,act,oact);
	RECORD(SIGACTION);
	return rc;
}



/*
 * sigaddset -- intercept sigaddset
 */
int sigaddset(sigset_t *set,int signo) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigaddset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(sigset_t *, int ))actual)(set, signo);
	RECORD(SIGADDSET);
	return rc;
}

/*
 * sigaltstack -- intercept sigaltstack
 */
int sigaltstack(const stack_t *ss,stack_t *oss) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigaltstack");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const stack_t *, stack_t *))actual)(ss,oss);
	RECORD(SIGALTSTACK);
	return rc;
}

/*
 * sigdelset -- intercept sigdelset
 */
int sigdelset(sigset_t *set,int signo) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigdelset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(sigset_t *, int ))actual)(set, signo);
	RECORD(SIGDELSET);
	return rc;
}

/*
 * sigemptyset -- intercept sigemptyset
 */
int sigemptyset(sigset_t *set) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigemptyset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(sigset_t *))actual)(set);
	RECORD(SIGEMPTYSET);
	return rc;
}

/*
 * sigfillset -- intercept sigfillset
 */
int sigfillset(sigset_t *set) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigfillset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(sigset_t *))actual)(set);
	RECORD(SIGFILLSET);
	return rc;
}


/*
 * sigfpe -- intercept sigfpe
 */
#if !defined(__linux)
sigfpe_handler_type sigfpe(sigfpe_code_type code,sigfpe_handler_type hdl) {
	static void *actual = NULL;
	DECLARE_TIME;
	sigfpe_handler_type	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigfpe");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((sigfpe_handler_type (*)(sigfpe_code_type,sigfpe_handler_type))actual)(code,hdl);
	RECORD(SIGFPE);
	return rc;
}
#endif


/*
 * sighold -- intercept sighold
 */
int sighold(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sighold");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(sig);
	RECORD(SIGHOLD_);
	return rc;
}

/*
 * sigignore -- intercept sigignore
 */
int sigignore(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigignore");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(sig);
	RECORD(SIGIGNORE_);
	return rc;
}

/*
 * sigismember -- intercept sigismember
 */
int sigismember(const sigset_t *set,int signo) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigismember");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const sigset_t *, int ))actual)(set, signo);
	RECORD(SIGISMEMBER);
	return rc;
}

/*
 * siglongjmp -- don't intercept siglongjmp, it doesn't return.
 */


/*
 * sigpause -- intercept sigpause
 */
#if !defined(__linux) /* Appears to be a #define on Linux. */
int sigpause(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigpause");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(sig);
	RECORD(SIGPAUSE_);
	return rc;
}
#endif

/*
 * sigpending -- intercept sigpending
 */
int sigpending(sigset_t *set) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigpending");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(sigset_t *))actual)(set);
	RECORD(SIGPENDING);
	return rc;
}

/*
 * sigprocmask -- intercept sigprocmask
 */
int sigprocmask(int how,const sigset_t *set,sigset_t *oset) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigprocmask");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const sigset_t *, sigset_t *))actual)(how,set,oset);
	RECORD(SIGPROCMASK);
	return rc;
}

/*
 * sigrelse -- intercept sigrelse
 */
int sigrelse(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigrelse");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(sig);
	RECORD(SIGRELSE_);
	return rc;
}

/*
 * sigsend -- intercept sigsend
 */
int sigsend(idtype_t idtype,id_t id,int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigsend");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(idtype_t, id_t, int ))actual)(idtype,id, sig);
	RECORD(SIGSEND);
	return rc;
}

/*
 * sigsendset -- intercept sigsendset
 */
#if !defined(__linux)
int sigsendset(const procset_t *psp,int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigsendset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const procset_t *, int))actual)(psp, sig);
	RECORD(SIGSENDSET);
	return rc;
}
#endif

#ifdef SIGSET_OK
/*
 * sigset -- intercept sigset
 *	sigset: void (*sigset(int sig,void (*disp)(int)))(int);
 */
void (* sigset(int sig,void (*disp)(int)))(int) {
	static void *actual = NULL;
	DECLARE_TIME;
	void (*	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void (* (*)(int,void (*)(int)))(int);)actual)(sig,disp);
	RECORD(SIGSET);
	return rc;
}
#endif

/*
 * sigsetjmp -- intercept sigsetjmp
 */
int sigsetjmp(sigjmp_buf env,int savemask) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigsetjmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(sigjmp_buf, int ))actual)(env, savemask);
	RECORD(SIGSETJMP);
	return rc;
}

/*
 * sigstack -- intercept sigstack
 */
int sigstack(struct sigstack *ss,struct sigstack *oss) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigstack");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(struct sigstack *, struct sigstack *))actual)(ss,oss);
	RECORD(SIGSTACK);
	return rc;
}

/*
 * sigsuspend -- intercept sigsuspend
 */
int sigsuspend(const sigset_t *set) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigsuspend");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const sigset_t *))actual)(set);
	RECORD(SIGSUSPEND);
	return rc;
}

/*
 * sigwait -- intercept sigwait
 */
#undef CAST
#if defined(__sun)
int sigwait(sigset_t *set) {
#define CAST (int (*)(sigset_t *))
#elif defined(__linux)
int sigwait(const sigset_t *set, int *sig) {
#define CAST (int (*)(const sigset_t *, int*))
#endif
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sigwait");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
#if defined(__sun)
	rc = (CAST actual)(set);
#elif defined(__linux) 
	rc = (CAST actual)(set, sig);
#endif
	RECORD(SIGWAIT);
	return rc;
}

/*
 * sleep -- intercept sleep
 */
unsigned int sleep(unsigned int seconds) {
	static void *actual = NULL;
	DECLARE_TIME;
	unsigned int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sleep");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((unsigned int (*)(unsigned int ))actual)(seconds);
	RECORD(SLEEP);
	return rc;
}


/*
 * snprintf -- intercept snprintf, call underlying vsnprintf
 */
int snprintf(char *s,size_t n,const char *format,/* args*/ ...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsnprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, size_t, const char *, va_list))actual)(s,n,format,ap);
	RECORD(SNPRINTF);
	va_end(ap);
	return rc;
}

/*
 * sprintf -- intercept sprintf, call underlying vsprintf
 */
int sprintf(char *s,const char *format,/* args*/ ...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, const char *, va_list))actual)(s,format,ap);
	RECORD(SPRINTF);
	va_end(ap);
	return rc;
}


/*
 * srand -- intercept srand
 */
void srand(unsigned int seed) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "srand");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(unsigned int ))actual)(seed);
	RECORD(SRAND);
	return;
}

/*
 * srand48 -- intercept srand48
 */
void srand48(long seedval) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "srand48");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(long ))actual)(seedval);
	RECORD(SRAND48);
	return;
}

/*
 * srandom -- intercept srandom
 */
void srandom(unsigned int seed) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "srandom");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(unsigned int ))actual)(seed);
	RECORD(SRANDOM);
	return;
}

/*
 * sscanf -- intercept sscanf, call underlying vsscanf
 */
int sscanf(const char *s,const char *format,...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *s, const char *, va_list))actual)(s,format,ap);
	RECORD(SSCANF);
	va_end(ap);
	return rc;
}

/*
 * stat -- intercept stat
 */
int stat(const char *path,struct stat *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "stat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, struct stat *))actual)(path,buf);
	RECORD(STAT);
	return rc;
}

/*
 * statvfs -- intercept statvfs
 */
int statvfs(const char *path,struct statvfs *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "statvfs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, struct statvfs *))actual)(path,buf);
	RECORD(STATVFS);
	return rc;
}

/*
 * stime -- intercept stime
 */
int stime(const time_t *tp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "stime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const time_t *))actual)(tp);
	RECORD(STIME);
	return rc;
}

/*
 * str2sig -- intercept str2sig
 */
int str2sig(const char *str,int *signum) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "str2sig");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, int *))actual)(str,signum);
	RECORD(STR2SIG);
	return rc;
}

/*
 * strcasecmp -- intercept strcasecmp
 */
int strcasecmp(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strcasecmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRCASECMP);
	return rc;
}

/*
 * strcat -- intercept strcat
 */
char * strcat(char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strcat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, const char *))actual)(s1,s2);
	RECORD(STRCAT);
	return rc;
}

/*
 * strchr -- intercept strchr
 */
char * strchr(const char *s,int c) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strchr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *s, int ))actual)(s, c);
	RECORD(STRCHR);
	return rc;
}

/*
 * strcmp -- intercept strcmp
 */
int strcmp(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strcmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRCMP);
	return rc;
}

/*
 * strcoll -- intercept strcoll
 */
int strcoll(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strcoll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRCOLL);
	return rc;
}

/*
 * strcpy -- intercept strcpy
 */
char * strcpy(char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strcpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, const char *))actual)(s1,s2);
	RECORD(STRCPY);
	return rc;
}

/*
 * strcspn -- intercept strcspn
 */
size_t strcspn(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strcspn");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRCSPN);
	return rc;
}

/*
 * strdup -- intercept strdup
 */
char * strdup(const char *s1) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strdup");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(s1);
	RECORD(STRDUP);
	return rc;
}

/*
 * strerror -- intercept strerror
 */
char * strerror(int errnum) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strerror");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(int ))actual)(errnum);
	RECORD(STRERROR);
	return rc;
}

#ifdef STRFMON_OK
/*
 * strfmon -- intercept strfmon, if possible...
 */
ssize_t strfmon(char *s,size_t maxsize,const char *format,...) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strfmon");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(char *, size_t, const char *, ...))actual)(s,maxsize,format,);
	RECORD(STRFMON);
	return rc;
}
#endif /* STRFMON_OK */

/*
 * strftime -- intercept strftime
 */
size_t strftime(char *s,size_t maxsize,const char *format,const struct tm *timeptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strftime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, size_t, const char *, const struct tm *))actual)(s,maxsize,format,timeptr);
	RECORD(STRFTIME);
	return rc;
}

/*
 * strlcat -- intercept strlcat
 */
size_t strlcat(char *dst,const char *src,size_t dstsize) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strlcat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, const char *, size_t ))actual)(dst,src,dstsize);
	RECORD(STRLCAT);
	return rc;
}

/*
 * strlcpy -- intercept strlcpy
 */
size_t strlcpy(char *dst,const char *src,size_t dstsize) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strlcpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, const char *, size_t ))actual)(dst,src,dstsize);
	RECORD(STRLCPY);
	return rc;
}

/*
 * strlen -- intercept strlen
 */
size_t strlen(const char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strlen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const char *s))actual)(s);
	RECORD(STRLEN);
	return rc;
}


/*
 * strncasecmp -- intercept strncasecmp
 */
int strncasecmp(const char *s1,const char *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strncasecmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *, size_t ))actual)(s1,s2,n);
	RECORD(STRNCASECMP);
	return rc;
}

/*
 * strncat -- intercept strncat
 */
char * strncat(char *s1,const char *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strncat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, const char *, size_t ))actual)(s1,s2,n);
	RECORD(STRNCAT);
	return rc;
}

/*
 * strncmp -- intercept strncmp
 */
int strncmp(const char *s1,const char *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strncmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *, size_t ))actual)(s1,s2,n);
	RECORD(STRNCMP);
	return rc;
}

/*
 * strncpy -- intercept strncpy
 */
char * strncpy(char *s1,const char *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strncpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, const char *, size_t ))actual)(s1,s2,n);
	RECORD(STRNCPY);
	return rc;
}

/*
 * strpbrk -- intercept strpbrk
 */
char * strpbrk(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strpbrk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRPBRK);
	return rc;
}

/*
 * strptime -- intercept strptime
 */
char * strptime(const char *buf,const char *format,struct tm *tm) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strptime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *, struct tm *))actual)(buf,format,tm);
	RECORD(STRPTIME);
	return rc;
}

/*
 * strrchr -- intercept strrchr
 */
char * strrchr(const char *s,int c) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strrchr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *s, int ))actual)(s, c);
	RECORD(STRRCHR);
	return rc;
}

/*
 * strsignal -- intercept strsignal
 */
char * strsignal(int sig) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strsignal");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(int ))actual)(sig);
	RECORD(STRSIGNAL);
	return rc;
}

/*
 * strspn -- intercept strspn
 */
size_t strspn(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strspn");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRSPN);
	return rc;
}

/*
 * strstr -- intercept strstr
 */
char * strstr(const char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strstr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(s1,s2);
	RECORD(STRSTR);
	return rc;
}

/*
 * strtod -- intercept strtod
 */
double strtod(const char *str,char **endptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtod");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(const char *, char **))actual)(str,endptr);
	RECORD(STRTOD);
	return rc;
}

/*
 * strtok -- intercept strtok
 */
char * strtok(char *s1,const char *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtok");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, const char *))actual)(s1,s2);
	RECORD(STRTOK);
	return rc;
}

/*
 * strtol -- intercept strtol
 */
long strtol(const char *str,char **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(const char *, char **, int ))actual)(str,endptr, base);
	RECORD(STRTOL);
	return rc;
}

/*
 * strtoll -- intercept strtoll
 */
long long strtoll(const char *str,char **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	long long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtoll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long long (*)(const char *, char **, int ))actual)(str,endptr, base);
	RECORD(STRTOLL);
	return rc;
}

/*
 * strtoul -- intercept strtoul
 */
unsigned long strtoul(const char *str,char **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	unsigned long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtoul");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((unsigned long (*)(const char *, char **, int ))actual)(str,endptr, base);
	RECORD(STRTOUL);
	return rc;
}

/*
 * strtoull -- intercept strtoull
 */
unsigned long long strtoull(const char *str,char **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	unsigned long long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtoull");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((unsigned long long (*)(const char *, char **, int ))actual)(str,endptr, base);
	RECORD(STRTOULL);
	return rc;
}

/*
 * strtows -- intercept strtows
 */
wchar_t * strtows(wchar_t *dst, char *src) { 
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strtows");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const char *))actual)(dst,src);
	RECORD(STRTOWS);
	return rc;
}

/*
 * strxfrm -- intercept strxfrm
 */
size_t strxfrm(char *s1,const char *s2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "strxfrm");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, const char *, size_t ))actual)(s1,s2,n);
	RECORD(STRXFRM);
	return rc;
}

/*
 * swab -- intercept swab
 */
void swab(const char *src,char *dest,ssize_t nbytes) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "swab");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const void *, char *, ssize_t ))actual)(src,dest,nbytes);
	RECORD(SWAB);
	return;
}

/*
 * swapcontext -- intercept swapcontext
 */
int swapcontext(ucontext_t *oucp,const ucontext_t *ucp) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "swapcontext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(ucontext_t *, const ucontext_t *))actual)(oucp,ucp);
	RECORD(SWAPCONTEXT);
	return rc;
}

/*
 * swapctl -- intercept swapctl
 */
int swapctl(int cmd,void *arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "swapctl");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, void *))actual)(cmd,arg);
	RECORD(SWAPCTL);
	return rc;
}

/*
 * swprintf -- intercept swprintf, call underlying vswprintf
 */
int swprintf(wchar_t *s,size_t n,const wchar_t *format,...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vswprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wchar_t *, size_t, const wchar_t *, va_list))actual)(s,n,format,ap);
	RECORD(SWPRINTF);
	va_end(ap);
	return rc;
}


/*
 * swscanf -- intercept swscanf, call underlying vswscanf
 */
int swscanf(const wchar_t *s,const wchar_t *format,...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vswscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *s, const wchar_t *, va_list))actual)(s,format, ap);
	RECORD(SWSCANF);
	va_end(ap);
	return rc;
}



/*
 * symlink -- intercept symlink
 */
int symlink(const char *name1,const char *name2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "symlink");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const char *))actual)(name1,name2);
	RECORD(SYMLINK);
	return rc;
}

/*
 * sync -- intercept sync
 */
void sync(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sync");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(SYNC);
	return;
}

/*
 * sysconf -- intercept sysconf
 */
long sysconf(int name) {
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sysconf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(int ))actual)(name);
	RECORD(SYSCONF);
	return rc;
}

#ifdef TRIADICS_OK
/*
 * sysfs -- intercept sysfs, which has three signatures...
 */
int sysfs(int opcode,const char *fsname) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sysfs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *))actual)(opcode,fsname);
	RECORD(SYSFS);
	return rc;
}
#endif /* TRIADICS_OK */


/*
 * sysinfo -- intercept sysinfo
 */
int sysinfo(int command,char *buf,long count) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "sysinfo");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, char *, long ))actual)(command,buf,count);
	RECORD(SYSINFO);
	return rc;
}


/*
 * syslog -- intercept syslog, call underlying vsyslog
 */
void syslog(int priority,const char *message,.../* arguments */) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;

	va_start(ap, message);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsyslog");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(int, const char *, va_list))actual)(priority,message,ap);
	RECORD(SYSLOG);
	va_end(ap);
	return;
}


/*
 * system -- intercept system
 */
int system(const char *string) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "system");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(string);
	RECORD(SYSTEM);
	return rc;
}

/*
 * tcdrain -- intercept tcdrain
 */
int tcdrain(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcdrain");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(TCDRAIN);
	return rc;
}

/*
 * tcflow -- intercept tcflow
 */
int tcflow(int fildes,int action) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcflow");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int ))actual)(fildes, action);
	RECORD(TCFLOW);
	return rc;
}

/*
 * tcflush -- intercept tcflush
 */
int tcflush(int fildes,int queue_selector) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcflush");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int ))actual)(fildes, queue_selector);
	RECORD(TCFLUSH);
	return rc;
}

/*
 * tcgetattr -- intercept tcgetattr
 */
int tcgetattr(int fildes,struct termios *termios_p) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcgetattr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, struct termios *))actual)(fildes,termios_p);
	RECORD(TCGETATTR);
	return rc;
}

/*
 * tcgetpgrp -- intercept tcgetpgrp
 */
pid_t tcgetpgrp(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcgetpgrp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(int ))actual)(fildes);
	RECORD(TCGETPGRP);
	return rc;
}

/*
 * tcgetsid -- intercept tcgetsid
 */
pid_t tcgetsid(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcgetsid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(int ))actual)(fildes);
	RECORD(TCGETSID);
	return rc;
}

/*
 * tcsendbreak -- intercept tcsendbreak
 */
int tcsendbreak(int fildes,int duration) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcsendbreak");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int ))actual)(fildes, duration);
	RECORD(TCSENDBREAK);
	return rc;
}

/*
 * tcsetattr -- intercept tcsetattr
 */
int tcsetattr(int fildes,int optional_actions,const struct termios *termios_p) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcsetattr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, const struct termios *))actual)(fildes, optional_actions,termios_p);
	RECORD(TCSETATTR);
	return rc;
}

/*
 * tcsetpgrp -- intercept tcsetpgrp
 */
int tcsetpgrp(int fildes,pid_t pgid_id) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tcsetpgrp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, pid_t ))actual)(fildes,pgid_id);
	RECORD(TCSETPGRP);
	return rc;
}


/*
 * tdelete -- intercept tdelete
 */
void * tdelete(const void *key,void **rootp,int (*compar)(const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tdelete");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *,void **,int (*)(const void *,const void *)))actual)(key,rootp,compar);
	RECORD(TDELETE);
	return rc;
}



/*
 * tell -- intercept tell
 */
off_t tell(int fd) {
	static void *actual = NULL;
	DECLARE_TIME;
	off_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tell");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((off_t (*)(int ))actual)(fd);
	RECORD(TELL);
	return rc;
}

/*
 * telldir -- intercept telldir
 */
long int telldir(DIR *dirp) {
	static void *actual = NULL;
	DECLARE_TIME;
	long int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "telldir");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long int (*)(DIR *))actual)(dirp);
	RECORD(TELLDIR);
	return rc;
}

/*
 * tempnam -- intercept tempnam
 */
char * tempnam(const char *dir,const char *pfx) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tempnam");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *, const char *))actual)(dir,pfx);
	RECORD(TEMPNAM);
	return rc;
}

/*
 * textdomain -- intercept textdomain
 */
char * textdomain(const char *domainname) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "textdomain");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(const char *))actual)(domainname);
	RECORD(TEXTDOMAIN);
	return rc;
}
/*
 * tfind -- intercept tfind
 */
void * tfind(const void *key,void * const *rootp,int (*compar)(const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tfind");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *,void * const *,int (*)(const void *,const void *)))actual)(key,rootp,compar);
	RECORD(TFIND);
	return rc;
}

/*
 * time -- intercept time
 */
time_t time(time_t *tloc) {
	static void *actual = NULL;
	DECLARE_TIME;
	time_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "time");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((time_t (*)(time_t *))actual)(tloc);
	RECORD(TIME);
	return rc;
}

/*
 * times -- intercept times
 */
clock_t times(struct tms *buffer) {
	static void *actual = NULL;
	DECLARE_TIME;
	clock_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "times");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((clock_t (*)(struct tms *))actual)(buffer);
	RECORD(TIMES);
	return rc;
}

/*
 * tmpfile -- intercept tmpfile
 */
FILE * tmpfile(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	FILE *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tmpfile");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((FILE * (*)(void))actual)();
	RECORD(TMPFILE);
	return rc;
}

/*
 * tmpnam -- intercept tmpnam
 */
char * tmpnam(char *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tmpnam");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *))actual)(s);
	RECORD(TMPNAM);
	return rc;
}

/*
 * toascii -- don't intercept toascii, it can be adefine
 * tolower 
 * toupper
 */

/*
 * towctrans -- intercept towctrans
 */
wint_t towctrans(wint_t wc,wctrans_t desc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "towctrans");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wint_t, wctrans_t ))actual)(wc,desc);
	RECORD(TOWCTRANS);
	return rc;
}

/*
 * towlower -- intercept towlower
 */
wint_t towlower(wint_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "towlower");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wint_t ))actual)(wc);
	RECORD(TOWLOWER);
	return rc;
}

/*
 * towupper -- intercept towupper
 */
wint_t towupper(wint_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "towupper");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wint_t ))actual)(wc);
	RECORD(TOWUPPER);
	return rc;
}

/*
 * truncate -- intercept truncate
 */
int truncate(const char *path,off_t length) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "truncate");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, off_t ))actual)(path,length);
	RECORD(TRUNCATE);
	return rc;
}


/*
 * tsearch -- intercept tsearch
 */
void * tsearch(const void *key,void **rootp,int (*compar)(const void *,const void *)) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tsearch");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(const void *,void **,int (*)(const void *,const void *)))actual)(key,rootp,compar);

	RECORD(TSEARCH);
	return rc;
}



/*
 * ttyname -- intercept ttyname
 */
char * ttyname(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ttyname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(int ))actual)(fildes);
	RECORD(TTYNAME);
	return rc;
}

/*
 * ttyslot -- intercept ttyslot
 */
int ttyslot(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ttyslot");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(TTYSLOT);
	return rc;
}

#ifdef TWALK_OK
/*
 * twalk -- intercept twalk
 */
void twalk(const void *root, void(*action)(void *,VISIT,int)) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "twalk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const void *,void(*)(void *,VISIT,int)))actual)(root,action);
	RECORD(TWALK);
	return;
}
#endif


/*
 * tzset -- intercept tzset
 */
void tzset(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "tzset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(TZSET);
	return;
}

/*
 * uadmin -- intercept uadmin
 */
int uadmin(int cmd,int fcn,uintptr_t mdep) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "uadmin");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, int, uintptr_t ))actual)(cmd, fcn,mdep);
	RECORD(UADMIN);
	return rc;
}

/*
 * ualarm -- intercept ualarm
 */
#if defined(__linux) 
#define useconds_t __useconds_t
#endif
useconds_t ualarm(useconds_t useconds,useconds_t interval) {
	static void *actual = NULL;
	DECLARE_TIME;
	useconds_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ualarm");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((useconds_t (*)(useconds_t, useconds_t))actual)(useconds,interval);
	RECORD(UALARM);
	return rc;
}

/*
 * ulckpwdf -- intercept ulckpwdf
 */
int ulckpwdf(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ulckpwdf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(void))actual)();
	RECORD(ULCKPWDF);
	return rc;
}

/*
 * ulimit -- intercept ulimit
 */
long ulimit(int cmd,/* long newlimit */...) {
	va_list	ap;
	static void *actual = NULL;
	DECLARE_TIME;
	long	rc;

	va_start(ap, cmd);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ulimit");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long (*)(int, long))actual)(cmd,va_arg(ap, long));
	RECORD(ULIMIT);
	va_end(ap);
	return rc;
}



/*
 * ulltostr -- intercept ulltostr
 */
char * ulltostr(unsigned long long value,char *endptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ulltostr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(unsigned long long, char *))actual)(value,endptr);
	RECORD(ULLTOSTR);
	return rc;
}

/*
 * umask -- intercept umask
 */
mode_t umask(mode_t cmask) {
	static void *actual = NULL;
	DECLARE_TIME;
	mode_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "umask");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((mode_t (*)(mode_t ))actual)(cmask);
	RECORD(UMASK);
	return rc;
}

/*
 * umount -- intercept umount
 */
int umount(const char *file) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "umount");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(file);
	RECORD(UMOUNT);
	return rc;
}

/*
 * umount2 -- intercept umount2
 */
int umount2(const char *file,int mflag) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "umount2");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, int ))actual)(file, mflag);
	RECORD(UMOUNT2);
	return rc;
}

/*
 * uname -- intercept uname
 */
int uname(struct utsname *name) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "uname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(struct utsname *))actual)(name);
	RECORD(UNAME);
	return rc;
}

/*
 * ungetc -- intercept ungetc
 */
int ungetc(int c,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ungetc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, FILE *))actual)(c,stream);
	RECORD(UNGETC);
	return rc;
}

/*
 * ungetwc -- intercept ungetwc
 */
wint_t ungetwc(wint_t wc,FILE *stream) {
	static void *actual = NULL;
	DECLARE_TIME;
	wint_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ungetwc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wint_t (*)(wint_t, FILE *))actual)(wc,stream);
	RECORD(UNGETWC);
	return rc;
}

/*
 * unlink -- intercept unlink
 */
int unlink(const char *path) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "unlink");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(path);
	RECORD(UNLINK);
	return rc;
}

/*
 * unlinkat -- intercept unlinkat
 */
int unlinkat(int dirfd,const char *path,int flag) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "unlinkat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, int ))actual)(dirfd,path, flag);
	RECORD(UNLINKAT);
	return rc;
}

/*
 * unlockpt -- intercept unlockpt
 */
int unlockpt(int fildes) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "unlockpt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int ))actual)(fildes);
	RECORD(UNLOCKPT);
	return rc;
}

/*
 * unordered -- intercept unordered
 */
int unordered(double dsrc1,double dsrc2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "unordered");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(double, double ))actual)(dsrc1, dsrc2);
	RECORD(UNORDERED);
	return rc;
}

/*
 * updwtmp -- intercept updwtmp
 */
void updwtmp(const char *wfile,struct utmp *utmp) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "updwtmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const char *, struct utmp *))actual)(wfile,utmp);
	RECORD(UPDWTMP);
	return;
}

/*
 * updwtmpx -- intercept updwtmpx
 */
void updwtmpx(const char *wfilex,struct utmpx *utmpx) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "updwtmpx");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(const char *, struct utmpx *))actual)(wfilex,utmpx);
	RECORD(UPDWTMPX);
	return;
}

/*
 * usleep -- intercept usleep
 */
int usleep(useconds_t useconds) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "usleep");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(useconds_t))actual)(useconds);
	RECORD(USLEEP);
	return rc;
}

/*
 * ustat -- intercept ustat
 */
int ustat(dev_t dev,struct ustat *buf) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "ustat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(dev_t, struct ustat *))actual)(dev,buf);
	RECORD(USTAT);
	return rc;
}

/*
 * utime -- intercept utime
 */
int utime(const char *path,const struct utimbuf *times) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "utime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const struct utimbuf *))actual)(path,times);
	RECORD(UTIME);
	return rc;
}


/*
 * utimes -- intercept utimes
 */
int utimes(const char *path,const struct timeval *times) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "utimes");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, const struct timeval *))actual)(path,times);
	RECORD(UTIMES);
	return rc;
}

/*
 * utmpname -- intercept utmpname
 */
int utmpname(const char *file) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "utmpname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(file);
	RECORD(UTMPNAME);
	return rc;
}

/*
 * utmpxname -- intercept utmpxname
 */
int utmpxname(const char *file) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "utmpxname");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *))actual)(file);
	RECORD(UTMPXNAME);
	return rc;
}

/*
 * valloc -- intercept valloc
 */
void * valloc(size_t size) {
	static void *actual = NULL;
	DECLARE_TIME;
	void *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "valloc");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((void * (*)(size_t))actual)(size);
	RECORD(VALLOC);
	return rc;
}

/*
 * vfork -- intercept vfork
 */
pid_t vfork(void) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfork");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(void))actual)();
	RECORD(VFORK);
	return rc;
}


/*
 * vfprintf -- intercept vfprintf
 */
int vfprintf(FILE *stream,const char *format,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const char *, va_list))actual)(stream,format,ap);
	RECORD(VFPRINTF);
	return rc;
}

/*
 * vfscanf -- intercept vfscanf
 */
int vfscanf(FILE *stream,const char *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const char *, va_list))actual)(stream,format,arg);
	RECORD(VFSCANF);
	return rc;
}

/*
 * vfwprintf -- intercept vfwprintf
 */
int vfwprintf(FILE *stream,const wchar_t *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfwprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const wchar_t *, va_list))actual)(stream,format,arg);
	RECORD(VFWPRINTF);
	return rc;
}

/*
 * vfwscanf -- intercept vfwscanf
 */
int vfwscanf(FILE *stream,const wchar_t *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vfwscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, const wchar_t *, va_list))actual)(stream,format,arg);
	RECORD(VFWSCANF);
	return rc;
}


/*
 * vhangup -- intercept vhangup
 */
#if defined(__sun) /* Linux has it return int. */
void vhangup(void) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vhangup");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(VHANGUP);
	return;
}
#endif

/*
 * vlfmt -- intercept vlfmt
 */
int vlfmt(FILE *stream,long flag,const char *format,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vlfmt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, long, const char *, va_list))actual)(stream,flag,format,ap);
	RECORD(VLFMT);
	return rc;
}

/*
 * vpfmt -- intercept vpfmt
 */
int vpfmt(FILE *stream,long flag,const char *format,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vpfmt");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(FILE *, long, const char *, va_list))actual)(stream,flag,format,ap);
	RECORD(VPFMT);
	return rc;
}


/*
 * vprintf -- intercept vprintf
 */
int vprintf(const char *format,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, va_list))actual)(format,ap);
	RECORD(VPRINTF);
	return rc;
}

/*
 * vscanf -- intercept vscanf
 */
int vscanf(const char *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, va_list))actual)(format,arg);
	RECORD(VSCANF);
	return rc;
}

/*
 * vsnprintf -- intercept vsnprintf
 */
int vsnprintf(char *s,size_t n,const char *format,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsnprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, size_t, const char *, va_list))actual)(s,n,format,ap);
	RECORD(VSNPRINTF);
	return rc;
}

/*
 * vsprintf -- intercept vsprintf
 */
int vsprintf(char *s,const char *format,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, const char *, va_list))actual)(s,format,ap);
	RECORD(VSPRINTF);
	return rc;
}

/*
 * vsscanf -- intercept vsscanf
 */
int vsscanf(const char *s,const char *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *s, const char *, va_list))actual)(s,format,arg);
	RECORD(VSSCANF);
	return rc;
}

/*
 * vswprintf -- intercept vswprintf
 */
int vswprintf(wchar_t *s,size_t n,const wchar_t *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vswprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wchar_t *, size_t, const wchar_t *, va_list))actual)(s,n,format,arg);
	RECORD(VSWPRINTF);
	return rc;
}

#ifdef REDECL_FIXED
/*
 * vswscanf -- intercept vswscanf
 */
int vswscanf(const wchar_t *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vswscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, va_list))actual)(format,arg);
	RECORD(VSWSCANF);
	return rc;
}
#endif /* REDECL_FIXED */

#ifdef VSYSLOG_FIXED
/*
 * vsyslog -- intercept vsyslog
 */
int vsyslog(int priority,const char *message,va_list ap) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vsyslog");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(int, const char *, va_list))actual)(priority,message,ap);
	RECORD(VSYSLOG);
	return rc;
}
#endif /* VSYSLOG_FIXED */

/*
 * vwprintf -- intercept vwprintf
 */
int vwprintf(const wchar_t *format,va_list arg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vwprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, va_list))actual)(format,arg);
	RECORD(VWPRINTF);
	return rc;
}


/*
 * wait -- intercept wait
 */
pid_t wait(int *stat_loc) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wait");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(int *))actual)(stat_loc);
	RECORD(WAIT);
	return rc;
}

/*
 * wait3 -- intercept wait3
 */
pid_t wait3(int *statusp,int options,struct rusage *rusage) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wait3");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(int *, int, struct  rusage *))actual)(statusp, options,rusage);
	RECORD(WAIT3);
	return rc;
}

/*
 * wait4 -- intercept wait4
 */
pid_t wait4(pid_t pid,int *statusp,int options,struct rusage *rusage) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wait4");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(pid_t, int *, int, struct rusage *))actual)(pid,statusp, options,rusage);
	RECORD(WAIT4);
	return rc;
}

/*
 * waitid -- intercept waitid
 */
int waitid(idtype_t idtype,id_t id,siginfo_t *infop,int options) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "waitid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(idtype_t, id_t, siginfo_t *, int ))actual)(idtype,id,infop, options);
	RECORD(WAITID);
	return rc;
}

/*
 * waitpid -- intercept waitpid
 */
pid_t waitpid(pid_t pid,int *stat_loc,int options) {
	static void *actual = NULL;
	DECLARE_TIME;
	pid_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "waitpid");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((pid_t (*)(pid_t, int *, int ))actual)(pid,stat_loc, options);
	RECORD(WAITPID);
	return rc;
}


/*
 * walkcontext -- intercept walkcontext
 */
int walkcontext(const ucontext_t *uptr,int (*operate_func)(uintptr_t,int,void *),void *usrarg) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "walkcontext");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const ucontext_t *,int (*)(uintptr_t,int,void *),void *))actual)(uptr,operate_func,usrarg);
	RECORD(WALKCONTEXT);
	return rc;
}


/*
 * watoll -- intercept watoll
 */
long long watoll(const wchar_t *nptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	long long	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "watoll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long long (*)(const wchar_t *))actual)(nptr);
	RECORD(WATOLL);
	return rc;
}

/*
 * wcrtomb -- intercept wcrtomb
 */
size_t wcrtomb(char *s,wchar_t wc,mbstate_t *ps) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcrtomb");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, wchar_t, mbstate_t *))actual)(s,wc,ps);
	RECORD(WCRTOMB);
	return rc;
}

/*
 * wcscat -- intercept wcscat
 */
wchar_t * wcscat(wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcscat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSCAT);
	return rc;
}

/*
 * wcschr -- intercept wcschr
 */
wchar_t * wcschr(const wchar_t *ws,wchar_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcschr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, wchar_t))actual)(ws,wc);
	RECORD(WCSCHR);
	return rc;
}

/*
 * wcscmp -- intercept wcscmp
 */
int wcscmp(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcscmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSCMP);
	return rc;
}

/*
 * wcscoll -- intercept wcscoll
 */
int wcscoll(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcscoll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSCOLL);
	return rc;
}

/*
 * wcscpy -- intercept wcscpy
 */
wchar_t * wcscpy(wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcscpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSCPY);
	return rc;
}

/*
 * wcscspn -- intercept wcscspn
 */
size_t wcscspn(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcscspn");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSCSPN);
	return rc;
}

/*
 * wcsftime -- intercept wcsftime
 */
size_t wcsftime(wchar_t *wcs,size_t maxsize, const wchar_t *format, const struct tm *timptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsftime");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(wchar_t *, size_t, const wchar_t *, const struct tm *))actual)(wcs,maxsize,format,timptr);
	RECORD(WCSFTIME);
	return rc;
}

/*
 * wcslen -- intercept wcslen
 */
size_t wcslen(const wchar_t *ws) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcslen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const wchar_t *))actual)(ws);
	RECORD(WCSLEN);
	return rc;
}

/*
 * wcsncat -- intercept wcsncat
 */
wchar_t * wcsncat(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsncat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WCSNCAT);
	return rc;
}

/*
 * wcsncmp -- intercept wcsncmp
 */
int wcsncmp(const wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsncmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WCSNCMP);
	return rc;
}

/*
 * wcsncpy -- intercept wcsncpy
 */
wchar_t * wcsncpy(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsncpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WCSNCPY);
	return rc;
}

/*
 * wcspbrk -- intercept wcspbrk
 */
wchar_t * wcspbrk(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcspbrk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSPBRK);
	return rc;
}

/*
 * wcsrchr -- intercept wcsrchr
 */
wchar_t * wcsrchr(const wchar_t *ws,wchar_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsrchr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, wchar_t))actual)(ws,wc);
	RECORD(WCSRCHR);
	return rc;
}

/*
 * wcsrtombs -- intercept wcsrtombs
 */
size_t wcsrtombs(char *dst,const wchar_t **src,size_t len,mbstate_t *ps) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsrtombs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, const wchar_t **, size_t, mbstate_t *))actual)(dst,src,len,ps);
	RECORD(WCSRTOMBS);
	return rc;
}

/*
 * wcsspn -- intercept wcsspn
 */
size_t wcsspn(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsspn");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSSPN);
	return rc;
}

/*
 * wcsstr -- intercept wcsstr
 */
wchar_t * wcsstr(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsstr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSSTR);
	return rc;
}

/*
 * wcstod -- intercept wcstod
 */
double wcstod(const wchar_t *nptr,wchar_t **endptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcstod");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(const wchar_t *, wchar_t **))actual)(nptr,endptr);
	RECORD(WCSTOD);
	return rc;
}

/*
 * wcstok -- intercept wcstok
 */
wchar_t * wcstok(wchar_t *ws1,const wchar_t *ws2, long **ufo) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcstok");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, long **))actual)(ws1,ws2, ufo);
	RECORD(WCSTOK);
	return rc;
}

/*
 * wcstol -- intercept wcstol
 */
long int wcstol(const wchar_t *nptr,wchar_t **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	long int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcstol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long int (*)(const wchar_t *, wchar_t **, int ))actual)(nptr,endptr, base);
	RECORD(WCSTOL);
	return rc;
}

/*
 * wcstombs -- intercept wcstombs
 */
size_t wcstombs(char *s,const wchar_t *pwcs,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcstombs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(char *, const wchar_t *, size_t ))actual)(s,pwcs,n);
	RECORD(WCSTOMBS);
	return rc;
}

/*
 * wcstoul -- intercept wcstoul
 */
unsigned long int wcstoul(const wchar_t *nptr,wchar_t **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	unsigned long int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcstoul");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((unsigned long int (*)(const wchar_t *, wchar_t **, int ))actual)(nptr,endptr, base);
	RECORD(WCSTOUL);
	return rc;
}

/*
 * wcswcs -- intercept wcswcs
 */
wchar_t * wcswcs(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcswcs");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WCSWCS);
	return rc;
}

/*
 * wcswidth -- intercept wcswidth
 */
int wcswidth(const wchar_t *pwcs,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcswidth");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, size_t ))actual)(pwcs,n);
	RECORD(WCSWIDTH);
	return rc;
}

/*
 * wcsxfrm -- intercept wcsxfrm
 */
size_t wcsxfrm(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcsxfrm");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WCSXFRM);
	return rc;
}

/*
 * wctob -- intercept wctob
 */
int wctob(wint_t c) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wctob");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wint_t ))actual)(c);
	RECORD(WCTOB);
	return rc;
}

/*
 * wctomb -- intercept wctomb
 */
int wctomb(char *s,wchar_t wchar) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wctomb");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(char *, wchar_t))actual)(s,wchar);
	RECORD(WCTOMB);
	return rc;
}


/*
 * wctrans -- intercept wctrans
 */
wctrans_t wctrans(const char *charclass) {
	static void *actual = NULL;
	DECLARE_TIME;
	wctrans_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wctrans");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wctrans_t (*)(const char *))actual)(charclass);
	RECORD(WCTRANS);
	return rc;
}

/*
 * wctype -- intercept wctype
 */
wctype_t wctype(const char *charclass) {
	static void *actual = NULL;
	DECLARE_TIME;
	wctype_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wctype");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wctype_t (*)(const char *))actual)(charclass);
	RECORD(WCTYPE);
	return rc;
}


/*
 * wcwidth -- intercept wcwidth
 */
int wcwidth(const wchar_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wcwidth");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wchar_t))actual)(wc);
	RECORD(WCWIDTH);
	return rc;
}

/*
 * wmemchr -- intercept wmemchr
 */
wchar_t * wmemchr(const wchar_t *ws,wchar_t wc,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wmemchr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, wchar_t, size_t ))actual)(ws,wc,n);
	RECORD(WMEMCHR);
	return rc;
}

/*
 * wmemcmp -- intercept wmemcmp
 */
int wmemcmp(const wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wmemcmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WMEMCMP);
	return rc;
}

/*
 * wmemcpy -- intercept wmemcpy
 */
wchar_t * wmemcpy(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wmemcpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WMEMCPY);
	return rc;
}

/*
 * wmemmove -- intercept wmemmove
 */
wchar_t * wmemmove(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wmemmove");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WMEMMOVE);
	return rc;
}

/*
 * wmemset -- intercept wmemset
 */
wchar_t * wmemset(wchar_t *ws,wchar_t wc,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wmemset");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, wchar_t, size_t ))actual)(ws,wc,n);
	RECORD(WMEMSET);
	return rc;
}

/*
 * wordexp -- intercept wordexp
 */
int wordexp(const char *words,wordexp_t *pwordexp,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wordexp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const char *, wordexp_t *, int ))actual)(words,pwordexp, flags);
	RECORD(WORDEXP);
	return rc;
}

/*
 * wordfree -- intercept wordfree
 */
void wordfree(wordexp_t *pwordexp) {
	static void *actual = NULL;
	DECLARE_TIME;


	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wordfree");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(wordexp_t *))actual)(pwordexp);
	RECORD(WORDFREE);
	return;
}

/*
 * wprintf -- intercept wprintf, call underlying vwprintf
 */
int wprintf(const wchar_t *format,...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int 	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vwprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, va_list))actual)(format,ap);
	RECORD(WPRINTF);
	va_end(ap);
	return rc;
}


/*
 * wracct -- intercept wracct
 */
int wracct(idtype_t idtype,id_t id,int flags) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wracct");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(idtype_t, id_t, int))actual)(idtype,id, flags);
	RECORD(WRACCT);
	return rc;
}

/*
 * write -- intercept write
 */
ssize_t write(int fildes,const void *buf,size_t nbyte) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "write");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, const void *, size_t ))actual)(fildes,buf,nbyte);
	RECORD(WRITE);
	return rc;
}

/*
 * writev -- intercept writev
 */
ssize_t writev(int fildes,const struct iovec *iov,int iovcnt) {
	static void *actual = NULL;
	DECLARE_TIME;
	ssize_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "writev");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((ssize_t (*)(int, const struct iovec *, int ))actual)(fildes,iov, iovcnt);
	RECORD(WRITEV);
	return rc;
}

/*
 * wscanf -- intercept wscanf, call underlying vwscanf
 */
int wscanf(const wchar_t *format,...) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vwscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, va_list))actual)(format,ap);
	RECORD(WSCANF);
	va_end(ap);
	return rc;
}


/*
 * wscasecmp -- intercept wscasecmp
 */
int wscasecmp(const wchar_t *s1,const wchar_t *s2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscasecmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *))actual)(s1,s2);
	RECORD(WSCASECMP);
	return rc;
}

/*
 * wscat -- intercept wscat
 */
wchar_t * wscat(wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSCAT);
	return rc;
}

/*
 * wschr -- intercept wschr
 */
wchar_t * wschr(const wchar_t *ws,wchar_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wschr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, wchar_t))actual)(ws,wc);
	RECORD(WSCHR);
	return rc;
}

/*
 * wscmp -- intercept wscmp
 */
int wscmp(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSCMP);
	return rc;
}

/*
 * wscol -- intercept wscol
 */
int wscol(const wchar_t *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *s))actual)(s);
	RECORD(WSCOL);
	return rc;
}

/*
 * wscoll -- intercept wscoll
 */
int wscoll(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscoll");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSCOLL);
	return rc;
}

/*
 * wscpy -- intercept wscpy
 */
wchar_t * wscpy(wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSCPY);
	return rc;
}

/*
 * wscspn -- intercept wscspn
 */
size_t wscspn(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wscspn");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSCSPN);
	return rc;
}

/*
 * wsdup -- intercept wsdup
 */
wchar_t * wsdup(const wchar_t *s) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsdup");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *))actual)(s);
	RECORD(WSDUP);
	return rc;
}

/*
 * wslen -- intercept wslen
 */
size_t wslen(const wchar_t *ws) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wslen");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const wchar_t *))actual)(ws);
	RECORD(WSLEN);
	return rc;
}

/*
 * wsncasecmp -- intercept wsncasecmp
 */
int wsncasecmp(const wchar_t *s1,const wchar_t *s2,unsigned n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsncasecmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *, unsigned))actual)(s1,s2, n);
	RECORD(WSNCASECMP);
	return rc;
}

/*
 * wsncat -- intercept wsncat
 */
wchar_t * wsncat(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsncat");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WSNCAT);
	return rc;
}

/*
 * wsncmp -- intercept wsncmp
 */
int wsncmp(const wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsncmp");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(const wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WSNCMP);
	return rc;
}

/*
 * wsncpy -- intercept wsncpy
 */
wchar_t * wsncpy(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsncpy");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WSNCPY);
	return rc;
}

/*
 * wspbrk -- intercept wspbrk
 */
wchar_t * wspbrk(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wspbrk");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSPBRK);
	return rc;
}



/*
 * wsprintf -- intercept wsprintf, call underlying vwsprintf
 */
int wsprintf(wchar_t *s,const char *format, /* arg */ ... ) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vwsprintf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wchar_t *,const char *, va_list))actual)(s,format,ap);
	RECORD(WSPRINTF);
	va_end(ap);
	return rc;
}


/*
 * wsrchr -- intercept wsrchr
 */
wchar_t * wsrchr(const wchar_t *ws,wchar_t wc) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsrchr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(const wchar_t *,wchar_t wc))actual)(ws,wc);
	RECORD(WSRCHR);
	return rc;
}


/*
 * wsscanf -- intercept wsscanf, call underlying vwsscanf
 */
int wsscanf(wchar_t *s,const char *format,/* pointer */ ... ) {
	va_list ap;
	static void *actual = NULL;
	DECLARE_TIME;
	int	rc;

	va_start(ap, format);
	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "vwsscanf");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((int (*)(wchar_t *, const char *, va_list ))actual)(s,format,ap);
	RECORD(WSSCANF);
	va_end(ap);
	return rc;
}


/*
 * wsspn -- intercept wsspn
 */
size_t wsspn(const wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsspn");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(const wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSSPN);
	return rc;
}

/*
 * wstod -- intercept wstod
 */
double wstod(const wchar_t *nptr,wchar_t **endptr) {
	static void *actual = NULL;
	DECLARE_TIME;
	double	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wstod");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((double (*)(const wchar_t *, wchar_t **))actual)(nptr,endptr);
	RECORD(WSTOD);
	return rc;
}

/*
 * wstok -- intercept wstok
 */
wchar_t * wstok(wchar_t *ws1,const wchar_t *ws2) {
	static void *actual = NULL;
	DECLARE_TIME;
	wchar_t *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wstok");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((wchar_t * (*)(wchar_t *, const wchar_t *))actual)(ws1,ws2);
	RECORD(WSTOK);
	return rc;
}

/*
 * wstol -- intercept wstol
 */
long int wstol(const wchar_t *nptr,wchar_t **endptr,int base) {
	static void *actual = NULL;
	DECLARE_TIME;
	long int	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wstol");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((long int (*)(const wchar_t *, wchar_t **, int ))actual)(nptr,endptr, base);
	RECORD(WSTOL);
	return rc;
}

/*
 * wstostr -- intercept wstostr
 */
char * wstostr(char *dst, wchar_t *src) { 
	static void *actual = NULL;
	DECLARE_TIME;
	char *	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wstostr");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((char * (*)(char *, const wchar_t *))actual)(dst,src);
	RECORD(WSTOSTR);
	return rc;
}

/*
 * wsxfrm -- intercept wsxfrm
 */
size_t wsxfrm(wchar_t *ws1,const wchar_t *ws2,size_t n) {
	static void *actual = NULL;
	DECLARE_TIME;
	size_t	rc;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "wsxfrm");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	rc = ((size_t (*)(wchar_t *, const wchar_t *, size_t ))actual)(ws1,ws2,n);
	RECORD(WSXFRM);
	return rc;
}

/*
 * yield -- intercept yield
 */
void yield(void) {
	static void *actual = NULL;
	DECLARE_TIME;

	if (actual == NULL) {
		actual = dlsym(RTLD_NEXT, "yield");
		assert(actual != NULL);
	}
	COLLECT_TZERO;
	((void (*)(void))actual)();
	RECORD(YIELD);
	return;
}


